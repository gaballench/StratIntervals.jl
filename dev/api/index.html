<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Public  API · StratIntervals.jl</title><meta name="title" content="Public  API · StratIntervals.jl"/><meta property="og:title" content="Public  API · StratIntervals.jl"/><meta property="twitter:title" content="Public  API · StratIntervals.jl"/><meta name="description" content="Documentation for StratIntervals.jl."/><meta property="og:description" content="Documentation for StratIntervals.jl."/><meta property="twitter:description" content="Documentation for StratIntervals.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="StratIntervals.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="StratIntervals.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">StratIntervals.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../stratinterval/">Stratigraphic intervals</a></li><li><a class="tocitem" href="../distributions/">Distributions</a></li><li><a class="tocitem" href="../conflation/">Conflation of PDFs</a></li><li><a class="tocitem" href="../turingmodel/">Sampling a stratigraphic interval and posterior predictive</a></li><li class="is-active"><a class="tocitem" href>Public  API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Public  API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Public  API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/gaballench/StratIntervals.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/gaballench/StratIntervals.jl/blob/main/docs/src/api.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Public-API"><a class="docs-heading-anchor" href="#Public-API">Public API</a><a id="Public-API-1"></a><a class="docs-heading-anchor-permalink" href="#Public-API" title="Permalink"></a></h1><ul><li><a href="#StratIntervals.FourParBeta"><code>StratIntervals.FourParBeta</code></a></li><li><a href="#StratIntervals.FourParBetaSampler"><code>StratIntervals.FourParBetaSampler</code></a></li><li><a href="#StratIntervals.RefOffExponential"><code>StratIntervals.RefOffExponential</code></a></li><li><a href="#StratIntervals.StratInterval"><code>StratIntervals.StratInterval</code></a></li><li><a href="#StratIntervals.ThreeParBeta"><code>StratIntervals.ThreeParBeta</code></a></li><li><a href="#StratIntervals.ThreeParBetaSampler"><code>StratIntervals.ThreeParBetaSampler</code></a></li><li><a href="#Base.maximum-Tuple{RefOffExponential}"><code>Base.maximum</code></a></li><li><a href="#Base.maximum-Tuple{FourParBeta}"><code>Base.maximum</code></a></li><li><a href="#Base.maximum-Tuple{ThreeParBeta}"><code>Base.maximum</code></a></li><li><a href="#Base.minimum-Tuple{FourParBeta}"><code>Base.minimum</code></a></li><li><a href="#Base.minimum-Tuple{ThreeParBeta}"><code>Base.minimum</code></a></li><li><a href="#Base.minimum-Tuple{RefOffExponential}"><code>Base.minimum</code></a></li><li><a href="#Base.rand-Tuple{Random.AbstractRNG, ThreeParBetaSampler}"><code>Base.rand</code></a></li><li><a href="#Base.rand-Tuple{Random.AbstractRNG, FourParBetaSampler}"><code>Base.rand</code></a></li><li><a href="#Base.rand-Tuple{Random.AbstractRNG, RefOffExponential}"><code>Base.rand</code></a></li><li><a href="#Distributions.cdf-Tuple{RefOffExponential, Real}"><code>Distributions.cdf</code></a></li><li><a href="#Distributions.cdf-Tuple{ThreeParBeta, Real}"><code>Distributions.cdf</code></a></li><li><a href="#Distributions.cdf-Tuple{FourParBeta, Real}"><code>Distributions.cdf</code></a></li><li><a href="#Distributions.insupport-Tuple{ThreeParBeta, Real}"><code>Distributions.insupport</code></a></li><li><a href="#Distributions.insupport-Tuple{FourParBeta, Real}"><code>Distributions.insupport</code></a></li><li><a href="#Distributions.insupport-Tuple{RefOffExponential, Real}"><code>Distributions.insupport</code></a></li><li><a href="#Distributions.logpdf-Tuple{FourParBeta, Real}"><code>Distributions.logpdf</code></a></li><li><a href="#Distributions.logpdf-Tuple{ThreeParBeta, Real}"><code>Distributions.logpdf</code></a></li><li><a href="#Distributions.logpdf-Tuple{RefOffExponential, Real}"><code>Distributions.logpdf</code></a></li><li><a href="#Distributions.pdf-Tuple{Product, Float64}"><code>Distributions.pdf</code></a></li><li><a href="#Distributions.pdf-Tuple{RefOffExponential, Real}"><code>Distributions.pdf</code></a></li><li><a href="#Distributions.pdf-Tuple{ThreeParBeta, Real}"><code>Distributions.pdf</code></a></li><li><a href="#Distributions.pdf-Tuple{FourParBeta, Real}"><code>Distributions.pdf</code></a></li><li><a href="#Distributions.product_distribution-Tuple{Vector{Normal{Float64}}}"><code>Distributions.product_distribution</code></a></li><li><a href="#Statistics.quantile-Tuple{ThreeParBeta, Real}"><code>Statistics.quantile</code></a></li><li><a href="#Statistics.quantile-Tuple{FourParBeta, Real}"><code>Statistics.quantile</code></a></li><li><a href="#Statistics.quantile-Tuple{RefOffExponential, Real}"><code>Statistics.quantile</code></a></li><li><a href="#StratIntervals.conflate-Tuple{Matrix{Float64}, Float64}"><code>StratIntervals.conflate</code></a></li><li><a href="#StratIntervals.conflate-Tuple{Vector{T} where T&lt;:Distribution{Univariate, Continuous}, Float64}"><code>StratIntervals.conflate</code></a></li><li><a href="#StratIntervals.conflate-Tuple{Product, Float64}"><code>StratIntervals.conflate</code></a></li><li><a href="#StratIntervals.quant-Tuple{Matrix{Float64}, Float64, Bool, Float64, Float64}"><code>StratIntervals.quant</code></a></li><li><a href="#StratIntervals.quant-Tuple{Vector{Any}, Float64, Bool, Float64, Float64}"><code>StratIntervals.quant</code></a></li><li><a href="#StratIntervals.sample_stratinterval-Tuple{Vector{StratInterval}, Vararg{Any, 4}}"><code>StratIntervals.sample_stratinterval</code></a></li><li><a href="#StratIntervals.sample_stratinterval-Tuple{StratInterval, Vararg{Any, 4}}"><code>StratIntervals.sample_stratinterval</code></a></li><li><a href="#StratIntervals.tau_collection-Tuple{Any, Float64}"><code>StratIntervals.tau_collection</code></a></li></ul><article><details class="docstring" open="true"><summary id="StratIntervals.FourParBeta"><a class="docstring-binding" href="#StratIntervals.FourParBeta"><code>StratIntervals.FourParBeta</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">FourParBeta</code></pre><p>Structure for constructing the PDF of stratigraphic interval estimation. It is a subtype of <code>ContinuousUnivariateDitribution</code>. This structure has four fields, corresponding to parameters: bounds on x [θ1,θ2] <em>in years before present</em> and the preservation parameters α, and β. </p><p><strong>examples</strong></p><pre><code class="language- hljs">using Distributions
rand(FourParBeta(5.0, 1.0, 1.0, 1.0)) # sample a random number from the FourParBeta with params θ1=5.0, θ2=1.0, α=1.0, β=1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaballench/StratIntervals.jl/blob/8c399e12c494376f5c6ae134c4f744d2a9e0add3/src/distributions.jl#L256-L269">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StratIntervals.FourParBetaSampler"><a class="docstring-binding" href="#StratIntervals.FourParBetaSampler"><code>StratIntervals.FourParBetaSampler</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">FourParBetaSampler</code></pre><p>This structure provides the parameters and function type for the FourParBeta, to be used with <code>Distributions.rand</code>. It is a subtype Sampleable of type Univariate, Continuous.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaballench/StratIntervals.jl/blob/8c399e12c494376f5c6ae134c4f744d2a9e0add3/src/distributions.jl#L443-L448">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StratIntervals.RefOffExponential"><a class="docstring-binding" href="#StratIntervals.RefOffExponential"><code>StratIntervals.RefOffExponential</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RefOffExponential</code></pre><p>Structure for constructing the PDF of a reflected and offset exponential distribution. It is a subtype of <code>ContinuousUnivariateDitribution</code>. This structure has three fields, corresponding to parameters: theta, offset, and reflect. </p><p><strong>examples</strong></p><pre><code class="language- hljs">using Distributions
rand(RefOffExponential(1, 10.0, 1)) # sample a random number from the RefOffExponential with params θ=1.0, o=10.0, ρ=1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaballench/StratIntervals.jl/blob/8c399e12c494376f5c6ae134c4f744d2a9e0add3/src/distributions.jl#L490-L503">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StratIntervals.StratInterval"><a class="docstring-binding" href="#StratIntervals.StratInterval"><code>StratIntervals.StratInterval</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">StratInterval(data, θ1_prior, θ2_prior, λ_prior)</code></pre><p>This structure allows to input the data for estimation of stratigraphic intervals. Four attributes are available:</p><p>data, a Vector{Real} with the time occurrences, or a Vector{ContinuousUnivariateDistribution} with time intervals instead of point data</p><p>θ1_prior, a ContinuousUnivariateDistribution, specifying the prior on θ1,</p><p>θ2_prior, a ContinuousUnivariateDistribution, specifying the prior on θ2, and</p><p>λ_prior, a ContinuousUnivariateDistribution, specifying the prior on λ.</p><p>When sampling all these parameters, the priors need to be distributions. However, it is possible to fix parameters to concrete values by specifying a Float64 instead of a  ContinuousUnivariateDistribution. Care must be taken to avoid fixing all of the parameters, at least one needs to be a ContinuousUnivariateDistribution.</p><p>Fixing a prior implies fixing its value in the model, so this needs to be used with extreme caution.</p><p>Fixing a prior essentially means calculating the posterior <em>conditional</em> to that observed value, and therefore does not correspond to the whole posterior. This is useful for simulation but is discouraged in empirical applications, no matter how certain we seem to be about the value for a given parameter.</p><p>An important exception to the rule above is when we have stratigraphic data for an extant lineage, in this case we can (and in fact should) fix θ2_prior to 0.0</p><p><strong>examples</strong></p><pre><code class="language- hljs">StratInterval([2.0, 3.1, 3.2, 4.6, 6.77], Normal(10, 2), Exponential(1), Normal(0, 1)) # use priors for all parameters
StratInterval([2.0, 3.1, 3.2, 4.6, 6.77], Normal(10, 2), 1.5, Normal(0, 1)) # fix θ2_prior to 1.5
StratInterval([2.0, 3.1, 3.2, 4.6, 6.77], 9.8, 1.5, Normal(0, 1)) # fix θ2_prior to 1.5 and θ1_prior to 9.8
StratInterval([2.0, 3.1, 3.2, 4.6, 6.77], 9.8, 1.5, 0.0) # this triggers an error
StratInterval([2.0, 3.1, 3.2, 4.6, 6.77], Normal(10, 2), Exponential(1), 0.0) # fix λ_prior to 0.0
StratInterval([2.0, 3.1, 3.2, 4.6, 6.77], Normal(10, 2), 0.0, Normal(0, 1)) # fix θ2_prior to 0.0 because the lineage is extant
StratInterval([Uniform(0, 2), Uniform(1, 2), Uniform(4, 6), Uniform(5, 9)], Normal(10, 2), Exponential(1), Normal(0, 1)) # intervals instead of point data</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaballench/StratIntervals.jl/blob/8c399e12c494376f5c6ae134c4f744d2a9e0add3/src/structs.jl#L4-L44">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StratIntervals.ThreeParBeta"><a class="docstring-binding" href="#StratIntervals.ThreeParBeta"><code>StratIntervals.ThreeParBeta</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ThreeParBeta</code></pre><p>Structure for constructing the PDF of stratigraphic interval estimation. It is a subtype of <code>ContinuousUnivariateDitribution</code>. This structure has three fields, corresponding to parameters: bounds on x [θ1,θ2] <em>in years before present</em> and the preservation parameter λ. </p><p><strong>examples</strong></p><pre><code class="language- hljs">using Distributions
rand(ThreeParBeta(5.0, 1.0, 0.0)) # sample a random number from the ThreeParBeta with params θ1=5.0, θ2=1.0, λ=0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaballench/StratIntervals.jl/blob/8c399e12c494376f5c6ae134c4f744d2a9e0add3/src/distributions.jl#L11-L24">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StratIntervals.ThreeParBetaSampler"><a class="docstring-binding" href="#StratIntervals.ThreeParBetaSampler"><code>StratIntervals.ThreeParBetaSampler</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ThreeParBetaSampler</code></pre><p>This structure provides the parameters and function type for the ThreeParBeta, to be used with <code>Distributions.rand</code>. It is a subtype Sampleable of type Univariate, Continuous.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaballench/StratIntervals.jl/blob/8c399e12c494376f5c6ae134c4f744d2a9e0add3/src/distributions.jl#L208-L213">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.maximum-Tuple{FourParBeta}"><a class="docstring-binding" href="#Base.maximum-Tuple{FourParBeta}"><code>Base.maximum</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Distributions.maximum(d::FourParBeta)</code></pre><p>This method extends the maximum function for the type FourParBeta. See <code>Distributions.maximum</code>. This function returns the <em>numerical</em> maximum bound in the support of the FourParBeta distribution. It is the parameter θ1.</p><p><strong>examples</strong></p><pre><code class="language- hljs">using Distributions
maximum(FourParBeta(5.0, 1.0, 1.0, 1.0))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaballench/StratIntervals.jl/blob/8c399e12c494376f5c6ae134c4f744d2a9e0add3/src/distributions.jl#L398-L411">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.maximum-Tuple{RefOffExponential}"><a class="docstring-binding" href="#Base.maximum-Tuple{RefOffExponential}"><code>Base.maximum</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Distributions.maximum(d::RefOffExponential)</code></pre><p>This method extends the maximum function for the type RefOffExponential. See <code>Distributions.maximum</code>. This function returns the <em>numerical</em> maximum bound in the support of the RefOffExponential distribution. It depends on whether it is reflected and offset or not.</p><p><strong>examples</strong></p><pre><code class="language- hljs">using Distributions
minimum(RefOffExponential(1, 10.0, 1))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaballench/StratIntervals.jl/blob/8c399e12c494376f5c6ae134c4f744d2a9e0add3/src/distributions.jl#L631-L644">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.maximum-Tuple{ThreeParBeta}"><a class="docstring-binding" href="#Base.maximum-Tuple{ThreeParBeta}"><code>Base.maximum</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Distributions.maximum(d::ThreeParBeta)</code></pre><p>This method extends the maximum function for the type ThreeParBeta. See <code>Distributions.maximum</code>. This function returns the <em>numerical</em> maximum bound in the support of the ThreeParBeta distribution. It is the parameter θ1.</p><p><strong>examples</strong></p><pre><code class="language- hljs">using Distributions
maximum(ThreeParBeta(5.0, 1.0, 0.0))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaballench/StratIntervals.jl/blob/8c399e12c494376f5c6ae134c4f744d2a9e0add3/src/distributions.jl#L163-L176">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.minimum-Tuple{FourParBeta}"><a class="docstring-binding" href="#Base.minimum-Tuple{FourParBeta}"><code>Base.minimum</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Distributions.minimum(d::FourParBeta)</code></pre><p>This method extends the minimum function for the type FourParBeta. See <code>Distributions.minimum</code>. This function returns the <em>numerical</em> minimum bound in the support of the FourParBeta distribution. It is the parameter θ2.</p><p><strong>examples</strong></p><pre><code class="language- hljs">using Distributions
minimum(FourParBeta(5.0, 1.0, 1.0, 1.0))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaballench/StratIntervals.jl/blob/8c399e12c494376f5c6ae134c4f744d2a9e0add3/src/distributions.jl#L375-L388">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.minimum-Tuple{RefOffExponential}"><a class="docstring-binding" href="#Base.minimum-Tuple{RefOffExponential}"><code>Base.minimum</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Distributions.minimum(d::RefOffExponential)</code></pre><p>This method extends the minimum function for the type RefOffExponential. See <code>Distributions.minimum</code>. This function returns the <em>numerical</em> minimum bound in the support of the RefOffExponential distribution. It depends on whether it is reflected and offset or not.</p><p><strong>examples</strong></p><pre><code class="language- hljs">using Distributions
minimum(RefOffExponential(1, 10.0, 1))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaballench/StratIntervals.jl/blob/8c399e12c494376f5c6ae134c4f744d2a9e0add3/src/distributions.jl#L606-L619">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.minimum-Tuple{ThreeParBeta}"><a class="docstring-binding" href="#Base.minimum-Tuple{ThreeParBeta}"><code>Base.minimum</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Distributions.minimum(d::ThreeParBeta)</code></pre><p>This method extends the minimum function for the type ThreeParBeta. See <code>Distributions.minimum</code>. This function returns the <em>numerical</em> minimum bound in the support of the ThreeParBeta distribution. It is the parameter θ2.</p><p><strong>examples</strong></p><pre><code class="language- hljs">using Distributions
minimum(ThreeParBeta(5.0, 1.0, 0.0))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaballench/StratIntervals.jl/blob/8c399e12c494376f5c6ae134c4f744d2a9e0add3/src/distributions.jl#L140-L153">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.rand-Tuple{Random.AbstractRNG, FourParBetaSampler}"><a class="docstring-binding" href="#Base.rand-Tuple{Random.AbstractRNG, FourParBetaSampler}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.rand(rng::AbstractRNG, d::FourParBetaSampler)</code></pre><p>This method extends the random sampler for the FourParBeta. It will return a single random Float64 from the FourParBeta when called with only the distribution specification, or a vector of Float64 when specifying how many numbers to sample.</p><p><strong>examples</strong></p><pre><code class="language- hljs">using Distributions
rand(FourParBeta(5.0, 1.0, 1.0, 1.0)) # return a single random number
rand(FourParBeta(5.0, 1.0, 1.0, 1.0), 10) # return a vector of 10 random numbers</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaballench/StratIntervals.jl/blob/8c399e12c494376f5c6ae134c4f744d2a9e0add3/src/distributions.jl#L458-L471">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.rand-Tuple{Random.AbstractRNG, RefOffExponential}"><a class="docstring-binding" href="#Base.rand-Tuple{Random.AbstractRNG, RefOffExponential}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.rand(rng::AbstractRNG, d::RefOffExponential)</code></pre><p>This method extends the random sampler for the RefOffExponential. It will return a single random Float64 from the RefOffExponential when called with only the distribution specification, or a vector of Float64 when specifying how many numbers to sample.</p><p><strong>examples</strong></p><pre><code class="language- hljs">using Distributions
rand(RefOffExponential(1, 10.0, 1)) # return a single random number
rand(RefOffExponential(1, 10.0, 1), 10) # return a vector of 10 random numbers</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaballench/StratIntervals.jl/blob/8c399e12c494376f5c6ae134c4f744d2a9e0add3/src/distributions.jl#L682-L695">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.rand-Tuple{Random.AbstractRNG, ThreeParBetaSampler}"><a class="docstring-binding" href="#Base.rand-Tuple{Random.AbstractRNG, ThreeParBetaSampler}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Base.rand(rng::AbstractRNG, d::ThreeParBetaSampler)</code></pre><p>This method extends the random sampler for the ThreeParBeta. It will return a single random Float64 from the ThreeParBeta when called with only the distribution specification, or a vector of Float64 when specifying how many numbers to sample.</p><p><strong>examples</strong></p><pre><code class="language- hljs">using Distributions
rand(ThreeParBeta(5.0, 1.0, 0.0)) # return a single random number
rand(ThreeParBeta(5.0, 1.0, 0.0), 10) # return a vector of 10 random numbers</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaballench/StratIntervals.jl/blob/8c399e12c494376f5c6ae134c4f744d2a9e0add3/src/distributions.jl#L222-L235">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Distributions.cdf-Tuple{FourParBeta, Real}"><a class="docstring-binding" href="#Distributions.cdf-Tuple{FourParBeta, Real}"><code>Distributions.cdf</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Distributions.cdf(d::FourParBeta, τ::Real)</code></pre><p>This method extends the cdf function for the type FourParBeta. See <code>Distributions.cdf</code>. The function returns the value of the cdf at a given value of τ.</p><p><strong>examples</strong></p><pre><code class="language- hljs">using Distributions
cdf(FourParBeta(5.0, 1.0, 1.0, 1.0), 2.5)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaballench/StratIntervals.jl/blob/8c399e12c494376f5c6ae134c4f744d2a9e0add3/src/distributions.jl#L323-L335">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Distributions.cdf-Tuple{RefOffExponential, Real}"><a class="docstring-binding" href="#Distributions.cdf-Tuple{RefOffExponential, Real}"><code>Distributions.cdf</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Distributions.cdf(d::RefOffExponential, x::Real)</code></pre><p>This method extends the cdf function for the type RefOffExponential. See <code>Distributions.cdf</code>. The function returns the value of the cdf at a given value of x.</p><p><strong>examples</strong></p><pre><code class="language- hljs">using Distributions
cdf(RefOffExponential(1, 10.0, 1), 2.5)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaballench/StratIntervals.jl/blob/8c399e12c494376f5c6ae134c4f744d2a9e0add3/src/distributions.jl#L550-L562">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Distributions.cdf-Tuple{ThreeParBeta, Real}"><a class="docstring-binding" href="#Distributions.cdf-Tuple{ThreeParBeta, Real}"><code>Distributions.cdf</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Distributions.cdf(d::ThreeParBeta, τ::Real)</code></pre><p>This method extends the cdf function for the type ThreeParBeta. See <code>Distributions.cdf</code>. The function returns the value of the cdf at a given value of τ.</p><p><strong>examples</strong></p><pre><code class="language- hljs">using Distributions
cdf(ThreeParBeta(5.0, 1.0, 0.0), 2.5)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaballench/StratIntervals.jl/blob/8c399e12c494376f5c6ae134c4f744d2a9e0add3/src/distributions.jl#L80-L92">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Distributions.insupport-Tuple{FourParBeta, Real}"><a class="docstring-binding" href="#Distributions.insupport-Tuple{FourParBeta, Real}"><code>Distributions.insupport</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Distributions.insupport(d::FourParBeta)</code></pre><p>This method extends the insupport function for the type FourParBeta. See <code>Distributions.insupport</code>. This function returns a Boolean being <code>true</code> if τ is in the support [θ1,θ2] of the FourParBeta distribution and <code>false</code> otherwise.</p><p><strong>examples</strong></p><pre><code class="language- hljs">using Distributions
insupport(FourParBeta(5.0, 1.0, 1.0, 1.0), 0.5) # false
insupport(FourParBeta(5.0, 1.0, 1.0, 1.0), 3.2) # true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaballench/StratIntervals.jl/blob/8c399e12c494376f5c6ae134c4f744d2a9e0add3/src/distributions.jl#L421-L434">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Distributions.insupport-Tuple{RefOffExponential, Real}"><a class="docstring-binding" href="#Distributions.insupport-Tuple{RefOffExponential, Real}"><code>Distributions.insupport</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Distributions.insupport(d::RefOffExponential, x::Real)</code></pre><p>This method extends the insupport function for the type RefOffExponential. See <code>Distributions.insupport</code>. This function returns a Boolean being <code>true</code> if x is in the support (-Inf,offset] when ρ = -1, or [offset,Inf) when standard, possible offset, and <code>false</code> otherwise.</p><p><strong>examples</strong></p><pre><code class="language- hljs">using Distributions
insupport(RefOffExponential(1, 10.0, 1), 0.5) # false
insupport(RefOffExponential(1, 10.0, 1), 12.0) # true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaballench/StratIntervals.jl/blob/8c399e12c494376f5c6ae134c4f744d2a9e0add3/src/distributions.jl#L656-L670">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Distributions.insupport-Tuple{ThreeParBeta, Real}"><a class="docstring-binding" href="#Distributions.insupport-Tuple{ThreeParBeta, Real}"><code>Distributions.insupport</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Distributions.insupport(d::ThreeParBeta)</code></pre><p>This method extends the insupport function for the type ThreeParBeta. See <code>Distributions.insupport</code>. This function returns a Boolean being <code>true</code> if τ is in the support [θ1,θ2] of the ThreeParBeta distribution and <code>false</code> otherwise.</p><p><strong>examples</strong></p><pre><code class="language- hljs">using Distributions
insupport(ThreeParBeta(5.0, 1.0, 0.0), 0.5) # false
insupport(ThreeParBeta(5.0, 1.0, 0.0), 3.2) # true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaballench/StratIntervals.jl/blob/8c399e12c494376f5c6ae134c4f744d2a9e0add3/src/distributions.jl#L186-L199">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Distributions.logpdf-Tuple{FourParBeta, Real}"><a class="docstring-binding" href="#Distributions.logpdf-Tuple{FourParBeta, Real}"><code>Distributions.logpdf</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Distributions.logpdf(d::FourParBeta, τ::Real)</code></pre><p>This method extends the logpdf function for the type FourParBeta. See <code>Distributions.logpdf</code>. The function returns the value of the logpdf at a given value of τ.</p><p><strong>examples</strong></p><pre><code class="language- hljs">using Distributions
logpdf(FourParBeta(5.0, 1.0, 1.0, 1.0), 2.5)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaballench/StratIntervals.jl/blob/8c399e12c494376f5c6ae134c4f744d2a9e0add3/src/distributions.jl#L304-L316">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Distributions.logpdf-Tuple{RefOffExponential, Real}"><a class="docstring-binding" href="#Distributions.logpdf-Tuple{RefOffExponential, Real}"><code>Distributions.logpdf</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Distributions.logpdf(d::RefOffExponential, x::Real)</code></pre><p>This method extends the logpdf function for the type RefOffExponential. See <code>Distributions.logpdf</code>. The function returns the value of the logpdf at a given value of x.</p><p><strong>examples</strong></p><pre><code class="language- hljs">using Distributions
logpdf(RefOffExponential(1, 10.0, 1), 2.5)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaballench/StratIntervals.jl/blob/8c399e12c494376f5c6ae134c4f744d2a9e0add3/src/distributions.jl#L531-L543">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Distributions.logpdf-Tuple{ThreeParBeta, Real}"><a class="docstring-binding" href="#Distributions.logpdf-Tuple{ThreeParBeta, Real}"><code>Distributions.logpdf</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Distributions.logpdf(d::ThreeParBeta, τ::Real)</code></pre><p>This method extends the logpdf function for the type ThreeParBeta. See <code>Distributions.logpdf</code>. The function returns the value of the logpdf at a given value of τ.</p><p><strong>examples</strong></p><pre><code class="language- hljs">using Distributions
logpdf(ThreeParBeta(5.0, 1.0, 0.0), 2.5)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaballench/StratIntervals.jl/blob/8c399e12c494376f5c6ae134c4f744d2a9e0add3/src/distributions.jl#L61-L73">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Distributions.pdf-Tuple{FourParBeta, Real}"><a class="docstring-binding" href="#Distributions.pdf-Tuple{FourParBeta, Real}"><code>Distributions.pdf</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Distributions.pdf(d::FouParBeta, τ::Real)</code></pre><p>This method extends the pdf function for the type FourParBeta so that the PDF is calculated given the parameters θ1, θ2, α, and β. The function returns the value of the PDF at a given value of τ.</p><p><strong>examples</strong></p><pre><code class="language- hljs">using Distributions
pdf(FourParBeta(5.0, 1.0, 1.0, 1.0), 2.5)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaballench/StratIntervals.jl/blob/8c399e12c494376f5c6ae134c4f744d2a9e0add3/src/distributions.jl#L278-L291">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Distributions.pdf-Tuple{Product, Float64}"><a class="docstring-binding" href="#Distributions.pdf-Tuple{Product, Float64}"><code>Distributions.pdf</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Distributions.pdf(d::Product, x::Float64)</code></pre><p>Method for specifying the product of an arbitrary vector of pdfs to be evaluated at the same x value.</p><p>Note: This method may need to be changed when Distributions deprecate Product. See product_distribution(dists::Vector{Normal{Float64}}).</p><p><strong>examples</strong></p><pre><code class="language- hljs">using Distributions
using Random
Random.seed!(4);
distribs = [Normal(0, 1), Normal(1, 1), Normal(2, 1)]
pdf(product_distribution(distribs), 1.5) # evaluate the product of three normals at x=1.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaballench/StratIntervals.jl/blob/8c399e12c494376f5c6ae134c4f744d2a9e0add3/src/conflate.jl#L172-L190">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Distributions.pdf-Tuple{RefOffExponential, Real}"><a class="docstring-binding" href="#Distributions.pdf-Tuple{RefOffExponential, Real}"><code>Distributions.pdf</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Distributions.pdf(d::RefOffExponential, x::Real)</code></pre><p>This method extends the pdf for the type RefOffExponential so that the PDF is calculated given the parameters θ, o, and ρ. The function returns the value of the PDF at a given value of x.</p><p><strong>examples</strong></p><pre><code class="language- hljs">using Distributions
pdf(RefOffExponential(1, 10.0, 1), 2.5)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaballench/StratIntervals.jl/blob/8c399e12c494376f5c6ae134c4f744d2a9e0add3/src/distributions.jl#L511-L524">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Distributions.pdf-Tuple{ThreeParBeta, Real}"><a class="docstring-binding" href="#Distributions.pdf-Tuple{ThreeParBeta, Real}"><code>Distributions.pdf</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Distributions.pdf(d::ThreeParBeta, τ::Real)</code></pre><p>This method extends the pdf function for the type ThreeParBeta so that the PDF is calculated given the parameters θ1, θ2 and λ. The function returns the value of the PDF at a given value of τ.</p><p><strong>examples</strong></p><pre><code class="language- hljs">using Distributions
pdf(ThreeParBeta(5.0, 1.0, 0.0), 2.5)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaballench/StratIntervals.jl/blob/8c399e12c494376f5c6ae134c4f744d2a9e0add3/src/distributions.jl#L32-L45">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Distributions.product_distribution-Tuple{Vector{Normal{Float64}}}"><a class="docstring-binding" href="#Distributions.product_distribution-Tuple{Vector{Normal{Float64}}}"><code>Distributions.product_distribution</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Distributions.product_distribution(dists::Vector{Normal{Float64}})</code></pre><p>Method for making product of Normals to behave as the generic one. The specialised one returning a MvNormal generates issues during conflation when all distribs are normal.</p><p>The methods associated to Product are going to be deprecated from Distributions. Prepare to modify this method accordingly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaballench/StratIntervals.jl/blob/8c399e12c494376f5c6ae134c4f744d2a9e0add3/src/conflate.jl#L159-L166">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Statistics.quantile-Tuple{FourParBeta, Real}"><a class="docstring-binding" href="#Statistics.quantile-Tuple{FourParBeta, Real}"><code>Statistics.quantile</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Distributions.quantile(d::FourParBeta, q::Real)</code></pre><p>This method extends the quantile function for the type FourParBeta. See <code>Distributions.quantile</code> and <code>Distributions.quantile(d::UnivariateDistribution, q::Real)</code>.</p><p><strong>examples</strong></p><pre><code class="language- hljs">using Distributions
quantile(FourParBeta(5.0, 1.0, 1.0, 1.0), 0.5) # calculate the median of the distribution</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaballench/StratIntervals.jl/blob/8c399e12c494376f5c6ae134c4f744d2a9e0add3/src/distributions.jl#L349-L361">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Statistics.quantile-Tuple{RefOffExponential, Real}"><a class="docstring-binding" href="#Statistics.quantile-Tuple{RefOffExponential, Real}"><code>Statistics.quantile</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Distributions.quantile(d::RefOffExponential, q::Real)</code></pre><p>This method extends the quantile function for the type RefOffExponential. See <code>Distributions.quantile</code> and <code>Distributions.quantile(d::UnivariateDistribution, q::Real)</code>.</p><p><strong>examples</strong></p><pre><code class="language- hljs">using Distributions
quantile(RefOffExponential(1, 10.0, 1), 0.5) # calculate the median of the distribution</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaballench/StratIntervals.jl/blob/8c399e12c494376f5c6ae134c4f744d2a9e0add3/src/distributions.jl#L580-L592">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Statistics.quantile-Tuple{ThreeParBeta, Real}"><a class="docstring-binding" href="#Statistics.quantile-Tuple{ThreeParBeta, Real}"><code>Statistics.quantile</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">Distributions.quantile(d::ThreeParBeta, q::Real)</code></pre><p>This method extends the quantile function for the type ThreeParBeta. See <code>Distributions.quantile</code> and <code>Distributions.quantile(d::UnivariateDistribution, q::Real)</code>.</p><p><strong>examples</strong></p><pre><code class="language- hljs">using Distributions
quantile(ThreeParBeta(5.0, 1.0, 0.0), 0.5) # calculate the median of the distribution</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaballench/StratIntervals.jl/blob/8c399e12c494376f5c6ae134c4f744d2a9e0add3/src/distributions.jl#L110-L122">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StratIntervals.conflate-Tuple{Matrix{Float64}, Float64}"><a class="docstring-binding" href="#StratIntervals.conflate-Tuple{Matrix{Float64}, Float64}"><code>StratIntervals.conflate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">conflate(d::Array{Float64, 2}, x::Float64)</code></pre><p>Conflation method for a matrix of floats, which are coming from a posterior predictive analysis, one column per stratigraphic interval.</p><p>It takes a matrix of empirical values to smooth, column-wise, and then apply the KDE and interpolation on each column.</p><p>Then it applies the conflation to these empirical pdfs and evaluate it at x.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaballench/StratIntervals.jl/blob/8c399e12c494376f5c6ae134c4f744d2a9e0add3/src/conflate.jl#L233-L242">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StratIntervals.conflate-Tuple{Product, Float64}"><a class="docstring-binding" href="#StratIntervals.conflate-Tuple{Product, Float64}"><code>StratIntervals.conflate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">conflate(d::Product, x::Float64)</code></pre><p>Conflation method for a product distribution, which are coming from calling pdf on a vector of pdfs.</p><p>It takes a vector of pdfs and conflate then evaluating the resulting pdf at x.</p><p>For conflation of empirical distributions see <code>conflate(d::Array{Float64, 2}, x::Float64)</code>@ref</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaballench/StratIntervals.jl/blob/8c399e12c494376f5c6ae134c4f744d2a9e0add3/src/conflate.jl#L214-L222">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StratIntervals.conflate-Tuple{Vector{T} where T&lt;:Distribution{Univariate, Continuous}, Float64}"><a class="docstring-binding" href="#StratIntervals.conflate-Tuple{Vector{T} where T&lt;:Distribution{Univariate, Continuous}, Float64}"><code>StratIntervals.conflate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">conflate(d::Vector{ContinuousUnivariateDitribution}, x::Float64)</code></pre><p>Conflation method for a vector of distributions.</p><p>It takes a vector of pdfs and conflate then evaluating the resulting pdf at x.</p><p>This is a convenience method for allowing either input as vector or product_distribution</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaballench/StratIntervals.jl/blob/8c399e12c494376f5c6ae134c4f744d2a9e0add3/src/conflate.jl#L201-L209">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StratIntervals.quant-Tuple{Matrix{Float64}, Float64, Bool, Float64, Float64}"><a class="docstring-binding" href="#StratIntervals.quant-Tuple{Matrix{Float64}, Float64, Bool, Float64, Float64}"><code>StratIntervals.quant</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">quant(taus::Array{Float64, 2}, p::Float64, lower_tail::Bool, min::Float64, max::Float64)</code></pre><p>A function for calculating the quantile for a given probability value on a conflated distribution. Whether to calculate lower or upper tail is available. The method uses constrained numerical optimisation, and therefore a minimum and maximum need to be specified.</p><p>taus a matrix of stacked empirical distributions, one distribution per column p the desired probability lower_tail a boolean defining whether we want to calculate the probability from -Inf to quant, if false it calculates the prob from quant to Inf min minimum value for the box optimisation, normally 0.0 max maximum value for the box optimisation, this should be something sensible outside of the bulk of the conflated PDF</p><p><strong>examples</strong></p><pre><code class="language- hljs">using Random
using Distributions
using StatsPlots
using StratIntervals
Random.seed!(1507)

#empirical1
empirical1_vec = rand(Normal(0, 1), 20)
#empirical2
empirical2_vec = rand(Uniform(1, 2), 20)
# stack them together in a matrix, column-wise
empirical_matrix = [empirical1_vec empirical2_vec]

xx = -5:0.01:5
yy = map(x -&gt; conflate(empirical_matrix, x), xx);

plot(xx, yy, label=&quot;Conflation&quot;)
density!(empirical1_vec, label=&quot;Empirical 1&quot;)
density!(empirical2_vec, label=&quot;Empirical 2&quot;)

quant(empirical_matrix, 0.025, true, -5.0, 5.0)
quant(empirical_matrix, 0.975, true, -5.0, 5.0)
quant(empirical_matrix, 0.025, false, -5.0, 5.0)
quant(empirical_matrix, 0.5, false, -5.0, 5.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaballench/StratIntervals.jl/blob/8c399e12c494376f5c6ae134c4f744d2a9e0add3/src/conflate.jl#L5-L46">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StratIntervals.quant-Tuple{Vector{Any}, Float64, Bool, Float64, Float64}"><a class="docstring-binding" href="#StratIntervals.quant-Tuple{Vector{Any}, Float64, Bool, Float64, Float64}"><code>StratIntervals.quant</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">quant(taus::Vector{Any}, p::Float64, lower_tail::Bool, min::Float64, max::Float64)</code></pre><p>A function for calculating the quantile for a given probability value on a conflated distribution. Whether to calculate lower or upper tail is available. The method uses constrained numerical optimisation, and therefore a minimum and maximum need to be specified.</p><p>taus a vector which comes from calling sample<em>stratinterval(vector{StratInterval}) p the desired probability lower</em>tail a boolean defining whether we want to calculate the probability from -Inf to quant, if false it calculates the prob from quant to Inf min minimum value for the box optimisation, normally 0.0 max maximum value for the box optimisation, this should be something sensible outside of the bulk of the conflated PDF</p><p><strong>examples</strong></p><pre><code class="language- hljs">using Random
using Distributions
using StatsPlots
using StratIntervals
using Turing
Random.seed!(1507)

setprogress!(false)

ndata = 100;
iters = 10000;

# first interval
true_lambda_1 = 0;
true_theta2_1 = 10;
true_theta1_1 = 22;
data_1 = rand(ThreeParBeta(true_theta1_1, true_theta2_1, true_lambda_1), ndata);

# second interval
true_lambda_2 = 1;
true_theta2_2 = 15;
true_theta1_2 = 30;
data_2 = rand(ThreeParBeta(true_theta1_2, true_theta2_2, true_lambda_2), ndata);

# specifying each StratInterval object
interval_1 = StratInterval(data_1, Normal(22, 3), Exponential(10), Normal(0,3));
interval_2 = StratInterval(data_2, Normal(30, 3), Exponential(15), Normal(1,3));

# construct the vector of StratIntervals
vecinterval = [interval_1, interval_2];

# MCMC sampling and posterior predictive
mystratint_postpredict_vec = sample_stratinterval(vecinterval, iters, NUTS(), false, true);

# now calculate the conflation of posterior predictives for the collection interval_1, interval_2

xx = 0:0.01:40;
yy = map(x -&gt; tau_collection(mystratint_postpredict_vec, x), xx);

plot(xx, yy, label=&quot;Conflation&quot;)
density!(mystratint_postpredict_vec[1][2], label=&quot;Postpredictive 1&quot;)
density!(mystratint_postpredict_vec[2][2], label=&quot;Postpredictive 2&quot;)

quant(mystratint_postpredict_vec, 0.025, true, 0.0, 800.0)
quant(mystratint_postpredict_vec, 0.975, true, 0.0, 800.0)
quant(mystratint_postpredict_vec, 0.025, false, 0.0, 800.0)
quant(mystratint_postpredict_vec, 0.5, false, 0.0, 800.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaballench/StratIntervals.jl/blob/8c399e12c494376f5c6ae134c4f744d2a9e0add3/src/conflate.jl#L69-L133">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StratIntervals.sample_stratinterval-Tuple{StratInterval, Vararg{Any, 4}}"><a class="docstring-binding" href="#StratIntervals.sample_stratinterval-Tuple{StratInterval, Vararg{Any, 4}}"><code>StratIntervals.sample_stratinterval</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">sample_stratinterval(data_priors::StratInterval, iters, sampler, prior, postpredict)</code></pre><p>This function samples the posterior distributions of the stratigraphic interval using MCMC.</p><p>Input are the data and priors as constructed using StratInterval(). iters is the number of iterations during sampling, sampler is the kind of sampler to use, e.g., HMC(epsilon, tau) or NUTS(), whether to sample from the prior, and finally the last argument specifies whether we want to calculate the posterior predictive distribution of τ.</p><p><strong>examples</strong></p><pre><code class="language- hljs">using Distributions
using Turing
using StratIntervals
my_strinterval = StratInterval([2.0, 3.1, 3.2, 4.6, 6.77], Normal(10, 2), Exponential(1), Normal(0, 1))
sample_stratinterval(my_strinterval, 10000, NUTS(), true, false) # sample from prior
sample_stratinterval(my_strinterval, 10000, NUTS(), false, false) # sample from posterior
sample_stratinterval(my_strinterval, 10000, NUTS(), false, true) # sample from posterior and calculate posterior predictive of tau</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaballench/StratIntervals.jl/blob/8c399e12c494376f5c6ae134c4f744d2a9e0add3/src/turingmodel.jl#L2-L22">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StratIntervals.sample_stratinterval-Tuple{Vector{StratInterval}, Vararg{Any, 4}}"><a class="docstring-binding" href="#StratIntervals.sample_stratinterval-Tuple{Vector{StratInterval}, Vararg{Any, 4}}"><code>StratIntervals.sample_stratinterval</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">sample_stratinterval(data_priors::Vector{StratInterval}, iters, sampler, prior, postpredict)</code></pre><p>This function samples the posterior distributions of a vector of  stratigraphic intervals using MCMC.</p><p>Input data is a vector of type StratInterval. iters is the number of iterations during sampling, sampler is the kind of sampler to use, e.g., HMC(epsilon, tau) or NUTS(), whether to sample from the prior, and finally the last argument specifies whether we want to calculate the posterior predictive distribution of τ.</p><p><strong>examples</strong></p><pre><code class="language- hljs">using Distributions
using Turing
ndata = 100
iters = 10000
# first interval
true_lambda_1 = 0
true_theta2_1 = 10
true_theta1_1 = 22
data_1 = rand(ThreeParBeta(true_theta1_1, true_theta2_1, true_lambda_1), ndata)
# second interval
true_lambda_2 = 1
true_theta2_2 = 15
true_theta1_2 = 30
data_2 = rand(ThreeParBeta(true_theta1_2, true_theta2_2, true_lambda_2), ndata)
interval_1 = StratInterval(data_1, Normal(22, 3), Exponential(10), Normal(0,3))
interval_2 = StratInterval(data_2, Normal(30, 3), Exponential(15), Normal(1,3))
# construct the vector of StratIntervals
vecinterval = [interval_1, interval_2]
# MCMC sampling
mystratint_mcmc_vec = sample_stratinterval(vecinterval, iters, NUTS(), false, false)
# MCMC sampling and posterior predictive
mystratint_postpredict_vec = sample_stratinterval(vecinterval, iters, NUTS(), false, true)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaballench/StratIntervals.jl/blob/8c399e12c494376f5c6ae134c4f744d2a9e0add3/src/turingmodel.jl#L122-L157">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StratIntervals.tau_collection-Tuple{Any, Float64}"><a class="docstring-binding" href="#StratIntervals.tau_collection-Tuple{Any, Float64}"><code>StratIntervals.tau_collection</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">tau_collection(taus, x::Float64)</code></pre><p>Calculation of the pdf for tau as a conflation of StratIntervals.</p><p>This uses the output of <code>sample_interval</code> with a <code>Vector{StratInterval}</code> and where <code>postpredict</code> is <code>true</code>.</p><p>The value of x is the evaluated using the conflation of the collection of stratigraphic intervals, that is, the tau for the co-occurrence of <code>StratInterval</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/gaballench/StratIntervals.jl/blob/8c399e12c494376f5c6ae134c4f744d2a9e0add3/src/conflate.jl#L254-L263">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../turingmodel/">« Sampling a stratigraphic interval and posterior predictive</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Tuesday 3 February 2026 22:20">Tuesday 3 February 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
