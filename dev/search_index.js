var documenterSearchIndex = {"docs":
[{"location":"api/#Public-API","page":"Public  API","title":"Public API","text":"","category":"section"},{"location":"api/","page":"Public  API","title":"Public  API","text":"","category":"page"},{"location":"api/","page":"Public  API","title":"Public  API","text":"Modules = [StratIntervals]","category":"page"},{"location":"api/#StratIntervals.FourParBeta","page":"Public  API","title":"StratIntervals.FourParBeta","text":"FourParBeta\n\nStructure for constructing the PDF of stratigraphic interval estimation. It is a subtype of ContinuousUnivariateDitribution. This structure has four fields, corresponding to parameters: bounds on x [θ1,θ2] in years before present and the preservation parameters α, and β. \n\nexamples\n\nusing Distributions\nrand(FourParBeta(5.0, 1.0, 1.0, 1.0)) # sample a random number from the FourParBeta with params θ1=5.0, θ2=1.0, α=1.0, β=1.0\n\n\n\n\n\n","category":"type"},{"location":"api/#StratIntervals.FourParBetaSampler","page":"Public  API","title":"StratIntervals.FourParBetaSampler","text":"FourParBetaSampler\n\nThis structure provides the parameters and function type for the FourParBeta, to be used with Distributions.rand. It is a subtype Sampleable of type Univariate, Continuous.\n\n\n\n\n\n","category":"type"},{"location":"api/#StratIntervals.RefOffExponential","page":"Public  API","title":"StratIntervals.RefOffExponential","text":"RefOffExponential\n\nStructure for constructing the PDF of a reflected and offset exponential distribution. It is a subtype of ContinuousUnivariateDitribution. This structure has three fields, corresponding to parameters: theta, offset, and reflect. \n\nexamples\n\nusing Distributions\nrand(RefOffExponential(1, 10.0, 1)) # sample a random number from the RefOffExponential with params θ=1.0, o=10.0, ρ=1\n\n\n\n\n\n","category":"type"},{"location":"api/#StratIntervals.RefOffExponentialSampler","page":"Public  API","title":"StratIntervals.RefOffExponentialSampler","text":"RefOffExponentialSampler\n\nThis structure provides the parameters and function type for the RefOffExponential, to be used with Distributions.rand. It is a subtype Sampleable of type Univariate, Continuous.\n\n\n\n\n\n","category":"type"},{"location":"api/#StratIntervals.StratInterval","page":"Public  API","title":"StratIntervals.StratInterval","text":"StratInterval(data, θ1_prior, θ2_prior, λ_prior)\n\nThis structure allows to input the data for estimation of stratigraphic intervals. Four attributes are available:\n\ndata, a Vector{Real} with the time occurrences, or a Vector{ContinuousUnivariateDistribution} with time intervals instead of point data\n\nθ1_prior, a ContinuousUnivariateDistribution, specifying the prior on θ1,\n\nθ2_prior, a ContinuousUnivariateDistribution, specifying the prior on θ2, and\n\nλ_prior, a ContinuousUnivariateDistribution, specifying the prior on λ.\n\nWhen sampling all these parameters, the priors need to be distributions. However, it is possible to fix parameters to concrete values by specifying a Float64 instead of a  ContinuousUnivariateDistribution. Care must be taken to avoid fixing all of the parameters, at least one needs to be a ContinuousUnivariateDistribution.\n\nFixing a prior implies fixing its value in the model, so this needs to be used with extreme caution.\n\nFixing a prior essentially means calculating the posterior conditional to that observed value, and therefore does not correspond to the whole posterior. This is useful for simulation but is discouraged in empirical applications, no matter how certain we seem to be about the value for a given parameter.\n\nAn important exception to the rule above is when we have stratigraphic data for an extant lineage, in this case we can (and in fact should) fix θ1_prior to 0.0\n\nexamples\n\nStratInterval([2.0, 3.1, 3.2, 4.6, 6.77], Normal(10, 2), Exponential(1), Normal(0, 1)) # use priors for all parameters\nStratInterval([2.0, 3.1, 3.2, 4.6, 6.77], Normal(10, 2), 1.5, Normal(0, 1)) # fix θ2_prior to 1.5\nStratInterval([2.0, 3.1, 3.2, 4.6, 6.77], 9.8, 1.5, Normal(0, 1)) # fix θ2_prior to 1.5 and θ1_prior to 9.8\nStratInterval([2.0, 3.1, 3.2, 4.6, 6.77], 9.8, 1.5, 0.0) # this triggers an error\nStratInterval([2.0, 3.1, 3.2, 4.6, 6.77], Normal(10, 2), Exponential(1), 0.0) # fix λ_prior to 0.0\nStratInterval([2.0, 3.1, 3.2, 4.6, 6.77], Normal(10, 2), 0.0, Normal(0, 1)) # fix θ2_prior to 0.0 because the lineage is extant\nStratInterval([Uniform(0, 2), Uniform(1, 2), Uniform(4, 6), Uniform(5, 9)], Normal(10, 2), Exponential(1), Normal(0, 1)) # intervals instead of point data\n\n\n\n\n\n","category":"type"},{"location":"api/#StratIntervals.ThreeParBeta","page":"Public  API","title":"StratIntervals.ThreeParBeta","text":"ThreeParBeta\n\nStructure for constructing the PDF of stratigraphic interval estimation. It is a subtype of ContinuousUnivariateDitribution. This structure has three fields, corresponding to parameters: bounds on x [θ1,θ2] in years before present and the preservation parameter λ. \n\nexamples\n\nusing Distributions\nrand(ThreeParBeta(5.0, 1.0, 0.0)) # sample a random number from the ThreeParBeta with params θ1=5.0, θ2=1.0, λ=0.0\n\n\n\n\n\n","category":"type"},{"location":"api/#StratIntervals.ThreeParBetaSampler","page":"Public  API","title":"StratIntervals.ThreeParBetaSampler","text":"ThreeParBetaSampler\n\nThis structure provides the parameters and function type for the ThreeParBeta, to be used with Distributions.rand. It is a subtype Sampleable of type Univariate, Continuous.\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.maximum-Tuple{FourParBeta}","page":"Public  API","title":"Base.maximum","text":"Distributions.maximum(d::FourParBeta)\n\nThis method extends the maximum function for the type FourParBeta. See Distributions.maximum. This function returns the numerical maximum bound in the support of the FourParBeta distribution. It is the parameter θ1.\n\nexamples\n\nusing Distributions\nmaximum(FourParBeta(5.0, 1.0, 1.0, 1.0))\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.maximum-Tuple{RefOffExponential}","page":"Public  API","title":"Base.maximum","text":"Distributions.maximum(d::RefOffExponential)\n\nThis method extends the maximum function for the type RefOffExponential. See Distributions.maximum. This function returns the numerical maximum bound in the support of the RefOffExponential distribution. It depends on whether it is reflected and offset or not.\n\nexamples\n\nusing Distributions\nminimum(RefOffExponential(1, 10.0, 1))\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.maximum-Tuple{ThreeParBeta}","page":"Public  API","title":"Base.maximum","text":"Distributions.maximum(d::ThreeParBeta)\n\nThis method extends the maximum function for the type ThreeParBeta. See Distributions.maximum. This function returns the numerical maximum bound in the support of the ThreeParBeta distribution. It is the parameter θ1.\n\nexamples\n\nusing Distributions\nmaximum(ThreeParBeta(5.0, 1.0, 0.0))\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.minimum-Tuple{FourParBeta}","page":"Public  API","title":"Base.minimum","text":"Distributions.minimum(d::FourParBeta)\n\nThis method extends the minimum function for the type FourParBeta. See Distributions.minimum. This function returns the numerical minimum bound in the support of the FourParBeta distribution. It is the parameter θ2.\n\nexamples\n\nusing Distributions\nminimum(FourParBeta(5.0, 1.0, 1.0, 1.0))\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.minimum-Tuple{RefOffExponential}","page":"Public  API","title":"Base.minimum","text":"Distributions.minimum(d::RefOffExponential)\n\nThis method extends the minimum function for the type RefOffExponential. See Distributions.minimum. This function returns the numerical minimum bound in the support of the RefOffExponential distribution. It depends on whether it is reflected and offset or not.\n\nexamples\n\nusing Distributions\nminimum(RefOffExponential(1, 10.0, 1))\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.minimum-Tuple{ThreeParBeta}","page":"Public  API","title":"Base.minimum","text":"Distributions.minimum(d::ThreeParBeta)\n\nThis method extends the minimum function for the type ThreeParBeta. See Distributions.minimum. This function returns the numerical minimum bound in the support of the ThreeParBeta distribution. It is the parameter θ2.\n\nexamples\n\nusing Distributions\nminimum(ThreeParBeta(5.0, 1.0, 0.0))\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.rand-Tuple{Random.AbstractRNG, FourParBetaSampler}","page":"Public  API","title":"Base.rand","text":"Base.rand(rng::AbstractRNG, d::FourParBetaSampler)\n\nThis method extends the random sampler for the FourParBeta. It will return a single random Float64 from the FourParBeta when called with only the distribution specification, or a vector of Float64 when specifying how many numbers to sample.\n\nexamples\n\nusing Distributions\nrand(FourParBeta(5.0, 1.0, 1.0, 1.0)) # return a single random number\nrand(FourParBeta(5.0, 1.0, 1.0, 1.0), 10) # return a vector of 10 random numbers\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.rand-Tuple{Random.AbstractRNG, RefOffExponentialSampler}","page":"Public  API","title":"Base.rand","text":"Base.rand(rng::AbstractRNG, d::RefOffExponentialSampler)\n\nThis method extends the random sampler for the RefOffExponential. It will return a single random Float64 from the RefOffExponential when called with only the distribution specification, or a vector of Float64 when specifying how many numbers to sample.\n\nexamples\n\nusing Distributions\nrand(RefOffExponential(1, 10.0, 1)) # return a single random number\nrand(RefOffExponential(1, 10.0, 1), 10) # return a vector of 10 random numbers\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.rand-Tuple{Random.AbstractRNG, ThreeParBetaSampler}","page":"Public  API","title":"Base.rand","text":"Base.rand(rng::AbstractRNG, d::ThreeParBetaSampler)\n\nThis method extends the random sampler for the ThreeParBeta. It will return a single random Float64 from the ThreeParBeta when called with only the distribution specification, or a vector of Float64 when specifying how many numbers to sample.\n\nexamples\n\nusing Distributions\nrand(ThreeParBeta(5.0, 1.0, 0.0)) # return a single random number\nrand(ThreeParBeta(5.0, 1.0, 0.0), 10) # return a vector of 10 random numbers\n\n\n\n\n\n","category":"method"},{"location":"api/#Distributions.cdf-Tuple{FourParBeta, Real}","page":"Public  API","title":"Distributions.cdf","text":"Distributions.cdf(d::FourParBeta, τ::Real)\n\nThis method extends the cdf function for the type FourParBeta. See Distributions.cdf. The function returns the value of the cdf at a given value of τ.\n\nexamples\n\nusing Distributions\ncdf(FourParBeta(5.0, 1.0, 1.0, 1.0), 2.5)\n\n\n\n\n\n","category":"method"},{"location":"api/#Distributions.cdf-Tuple{RefOffExponential, Real}","page":"Public  API","title":"Distributions.cdf","text":"Distributions.cdf(d::RefOffExponential, x::Real)\n\nThis method extends the cdf function for the type RefOffExponential. See Distributions.cdf. The function returns the value of the cdf at a given value of x.\n\nexamples\n\nusing Distributions\ncdf(RefOffExponential(1, 10.0, 1), 2.5)\n\n\n\n\n\n","category":"method"},{"location":"api/#Distributions.cdf-Tuple{ThreeParBeta, Real}","page":"Public  API","title":"Distributions.cdf","text":"Distributions.cdf(d::ThreeParBeta, τ::Real)\n\nThis method extends the cdf function for the type ThreeParBeta. See Distributions.cdf. The function returns the value of the cdf at a given value of τ.\n\nexamples\n\nusing Distributions\ncdf(ThreeParBeta(5.0, 1.0, 0.0), 2.5)\n\n\n\n\n\n","category":"method"},{"location":"api/#Distributions.insupport-Tuple{FourParBeta, Real}","page":"Public  API","title":"Distributions.insupport","text":"Distributions.insupport(d::FourParBeta)\n\nThis method extends the insupport function for the type FourParBeta. See Distributions.insupport. This function returns a Boolean being true if τ is in the support [θ1,θ2] of the FourParBeta distribution and false otherwise.\n\nexamples\n\nusing Distributions\ninsupport(FourParBeta(5.0, 1.0, 1.0, 1.0), 0.5) # false\ninsupport(FourParBeta(5.0, 1.0, 1.0, 1.0), 3.2) # true\n\n\n\n\n\n","category":"method"},{"location":"api/#Distributions.insupport-Tuple{RefOffExponential, Real}","page":"Public  API","title":"Distributions.insupport","text":"Distributions.insupport(d::RefOffExponential, x::Real)\n\nThis method extends the insupport function for the type RefOffExponential. See Distributions.insupport. This function returns a Boolean being true if x is in the support (-Inf,offset] when ρ = -1, or [offset,Inf) when standard, possible offset, and false otherwise.\n\nexamples\n\nusing Distributions\ninsupport(RefOffExponential(1, 10.0, 1), 0.5) # false\ninsupport(RefOffExponential(1, 10.0, 1), 12.0) # true\n\n\n\n\n\n","category":"method"},{"location":"api/#Distributions.insupport-Tuple{ThreeParBeta, Real}","page":"Public  API","title":"Distributions.insupport","text":"Distributions.insupport(d::ThreeParBeta)\n\nThis method extends the insupport function for the type ThreeParBeta. See Distributions.insupport. This function returns a Boolean being true if τ is in the support [θ1,θ2] of the ThreeParBeta distribution and false otherwise.\n\nexamples\n\nusing Distributions\ninsupport(ThreeParBeta(5.0, 1.0, 0.0), 0.5) # false\ninsupport(ThreeParBeta(5.0, 1.0, 0.0), 3.2) # true\n\n\n\n\n\n","category":"method"},{"location":"api/#Distributions.logpdf-Tuple{FourParBeta, Real}","page":"Public  API","title":"Distributions.logpdf","text":"Distributions.logpdf(d::FourParBeta, τ::Real)\n\nThis method extends the logpdf function for the type FourParBeta. See Distributions.logpdf. The function returns the value of the logpdf at a given value of τ.\n\nexamples\n\nusing Distributions\nlogpdf(FourParBeta(5.0, 1.0, 1.0, 1.0), 2.5)\n\n\n\n\n\n","category":"method"},{"location":"api/#Distributions.logpdf-Tuple{RefOffExponential, Real}","page":"Public  API","title":"Distributions.logpdf","text":"Distributions.logpdf(d::RefOffExponential, x::Real)\n\nThis method extends the logpdf function for the type RefOffExponential. See Distributions.logpdf. The function returns the value of the logpdf at a given value of x.\n\nexamples\n\nusing Distributions\nlogpdf(RefOffExponential(1, 10.0, 1), 2.5)\n\n\n\n\n\n","category":"method"},{"location":"api/#Distributions.logpdf-Tuple{ThreeParBeta, Real}","page":"Public  API","title":"Distributions.logpdf","text":"Distributions.logpdf(d::ThreeParBeta, τ::Real)\n\nThis method extends the logpdf function for the type ThreeParBeta. See Distributions.logpdf. The function returns the value of the logpdf at a given value of τ.\n\nexamples\n\nusing Distributions\nlogpdf(ThreeParBeta(5.0, 1.0, 0.0), 2.5)\n\n\n\n\n\n","category":"method"},{"location":"api/#Distributions.pdf-Tuple{FourParBeta, Real}","page":"Public  API","title":"Distributions.pdf","text":"Distributions.pdf(d::FouParBeta, τ::Real)\n\nThis method extends the pdf function for the type FourParBeta so that the PDF is calculated given the parameters θ1, θ2, α, and β. The function returns the value of the PDF at a given value of τ.\n\nexamples\n\nusing Distributions\npdf(FourParBeta(5.0, 1.0, 1.0, 1.0), 2.5)\n\n\n\n\n\n","category":"method"},{"location":"api/#Distributions.pdf-Tuple{Product, Float64}","page":"Public  API","title":"Distributions.pdf","text":"Distributions.pdf(d::Product, x::Float64)\n\nMethod for specifying the product of an arbitrary vector of pdfs to be evaluated at the same x value.\n\nNote: This method may need to be changed when Distributions deprecate Product. See product_distribution(dists::Vector{Normal{Float64}}).\n\nexamples\n\nusing Distributions\nusing Random\nRandom.seed!(4);\ndistribs = [Normal(0, 1), Normal(1, 1), Normal(2, 1)]\npdf(product_distribution(distribs), 1.5) # evaluate the product of three normals at x=1.5\n\n\n\n\n\n","category":"method"},{"location":"api/#Distributions.pdf-Tuple{RefOffExponential, Real}","page":"Public  API","title":"Distributions.pdf","text":"Distributions.pdf(d::RefOffExponential, x::Real)\n\nThis method extends the pdf for the type RefOffExponential so that the PDF is calculated given the parameters θ, o, and ρ. The function returns the value of the PDF at a given value of x.\n\nexamples\n\nusing Distributions\npdf(RefOffExponential(1, 10.0, 1), 2.5)\n\n\n\n\n\n","category":"method"},{"location":"api/#Distributions.pdf-Tuple{ThreeParBeta, Real}","page":"Public  API","title":"Distributions.pdf","text":"Distributions.pdf(d::ThreeParBeta, τ::Real)\n\nThis method extends the pdf function for the type ThreeParBeta so that the PDF is calculated given the parameters θ1, θ2 and λ. The function returns the value of the PDF at a given value of τ.\n\nexamples\n\nusing Distributions\npdf(ThreeParBeta(5.0, 1.0, 0.0), 2.5)\n\n\n\n\n\n","category":"method"},{"location":"api/#Distributions.product_distribution-Tuple{Vector{Normal{Float64}}}","page":"Public  API","title":"Distributions.product_distribution","text":"Distributions.product_distribution(dists::Vector{Normal{Float64}})\n\nMethod for making product of Normals to behave as the generic one. The specialised one returning a MvNormal generates issues during conflation when all distribs are normal.\n\nThe methods associated to Product are going to be deprecated from Distributions. Prepare to modify this method accordingly.\n\n\n\n\n\n","category":"method"},{"location":"api/#Statistics.quantile-Tuple{FourParBeta, Real}","page":"Public  API","title":"Statistics.quantile","text":"Distributions.quantile(d::FourParBeta, q::Real)\n\nThis method extends the quantile function for the type FourParBeta. See Distributions.quantile and Distributions.quantile(d::UnivariateDistribution, q::Real).\n\nexamples\n\nusing Distributions\nquantile(FourParBeta(5.0, 1.0, 1.0, 1.0), 0.5) # calculate the median of the distribution\n\n\n\n\n\n","category":"method"},{"location":"api/#Statistics.quantile-Tuple{RefOffExponential, Real}","page":"Public  API","title":"Statistics.quantile","text":"Distributions.quantile(d::RefOffExponential, q::Real)\n\nThis method extends the quantile function for the type RefOffExponential. See Distributions.quantile and Distributions.quantile(d::UnivariateDistribution, q::Real).\n\nexamples\n\nusing Distributions\nquantile(RefOffExponential(1, 10.0, 1), 0.5) # calculate the median of the distribution\n\n\n\n\n\n","category":"method"},{"location":"api/#Statistics.quantile-Tuple{ThreeParBeta, Real}","page":"Public  API","title":"Statistics.quantile","text":"Distributions.quantile(d::ThreeParBeta, q::Real)\n\nThis method extends the quantile function for the type ThreeParBeta. See Distributions.quantile and Distributions.quantile(d::UnivariateDistribution, q::Real).\n\nexamples\n\nusing Distributions\nquantile(ThreeParBeta(5.0, 1.0, 0.0), 0.5) # calculate the median of the distribution\n\n\n\n\n\n","category":"method"},{"location":"api/#StratIntervals.conflate-Tuple{Matrix{Float64}, Float64}","page":"Public  API","title":"StratIntervals.conflate","text":"conflate(d::Array{Float64, 2}, x::Float64)\n\nConflation method for a matrix of floats, which are coming from a posterior predictive analysis, one column per stratigraphic interval.\n\nIt takes a matrix of empirical values to smooth, column-wise, and then apply the KDE and interpolation on each column.\n\nThen it applies the conflation to these empirical pdfs and evaluate it at x.\n\n\n\n\n\n","category":"method"},{"location":"api/#StratIntervals.conflate-Tuple{Product, Float64}","page":"Public  API","title":"StratIntervals.conflate","text":"conflate(d::Product, x::Float64)\n\nConflation method for a product distribution, which are coming from calling pdf on a vector of pdfs.\n\nIt takes a vector of pdfs and conflate then evaluating the resulting pdf at x.\n\nFor conflation of empirical distributions see conflate(d::Array{Float64, 2}, x::Float64)@ref\n\n\n\n\n\n","category":"method"},{"location":"api/#StratIntervals.conflate-Tuple{Vector{T} where T<:Distribution{Univariate, Continuous}, Float64}","page":"Public  API","title":"StratIntervals.conflate","text":"conflate(d::Vector{ContinuousUnivariateDitribution}, x::Float64)\n\nConflation method for a vector of distributions.\n\nIt takes a vector of pdfs and conflate then evaluating the resulting pdf at x.\n\nThis is a convenience method for allowing either input as vector or product_distribution\n\n\n\n\n\n","category":"method"},{"location":"api/#StratIntervals.sample_stratinterval-Tuple{StratInterval, Vararg{Any, 4}}","page":"Public  API","title":"StratIntervals.sample_stratinterval","text":"sample_stratinterval(data_priors::StratInterval, iters, sampler, prior, postpredict)\n\nThis function samples the posterior distributions of the stratigraphic interval using MCMC.\n\nInput are the data and priors as constructed using StratInterval(). iters is the number of iterations during sampling, sampler is the kind of sampler to use, e.g., HMC(epsilon, tau) or NUTS(), whether to sample from the prior, and finally the last argument specifies whether we want to calculate the posterior predictive distribution of τ.\n\nexamples\n\nusing Distributions\nusing Turing\nusing StratIntervals\nmy_strinterval = StratInterval([2.0, 3.1, 3.2, 4.6, 6.77], Normal(10, 2), Exponential(1), Normal(0, 1))\nsample_stratinterval(my_strinterval, 10000, NUTS(), true, false) # sample from prior\nsample_stratinterval(my_strinterval, 10000, NUTS(), false, false) # sample from posterior\nsample_stratinterval(my_strinterval, 10000, NUTS(), false, true) # sample from posterior and calculate posterior predictive of tau\n\n\n\n\n\n","category":"method"},{"location":"api/#StratIntervals.sample_stratinterval-Tuple{Vector{StratInterval}, Vararg{Any, 4}}","page":"Public  API","title":"StratIntervals.sample_stratinterval","text":"sample_stratinterval(data_priors::Vector{StratInterval}, iters, sampler, prior, postpredict)\n\nThis function samples the posterior distributions of a vector of  stratigraphic intervals using MCMC.\n\nInput data is a vector of type StratInterval. iters is the number of iterations during sampling, sampler is the kind of sampler to use, e.g., HMC(epsilon, tau) or NUTS(), whether to sample from the prior, and finally the last argument specifies whether we want to calculate the posterior predictive distribution of τ.\n\nexamples\n\nusing Distributions\nusing Turing\nndata = 100\niters = 10000\n# first interval\ntrue_lambda_1 = 0\ntrue_theta2_1 = 10\ntrue_theta1_1 = 22\ndata_1 = rand(ThreeParBeta(true_theta1_1, true_theta2_1, true_lambda_1), ndata)\n# second interval\ntrue_lambda_2 = 1\ntrue_theta2_2 = 15\ntrue_theta1_2 = 30\ndata_2 = rand(ThreeParBeta(true_theta1_2, true_theta2_2, true_lambda_2), ndata)\ninterval_1 = StratInterval(data_1, Normal(22, 3), Exponential(10), Normal(0,3))\ninterval_2 = StratInterval(data_2, Normal(30, 3), Exponential(15), Normal(1,3))\n# construct the vector of StratIntervals\nvecinterval = [interval_1, interval_2]\n# MCMC sampling\nmystratint_mcmc_vec = sample_stratinterval(vecinterval, iters, NUTS(), false, false)\n# MCMC sampling and posterior predictive\nmystratint_postpredict_vec = sample_stratinterval(vecinterval, iters, NUTS(), false, true)\n\n\n\n\n\n","category":"method"},{"location":"api/#StratIntervals.tau_collection-Tuple{Any, Float64}","page":"Public  API","title":"StratIntervals.tau_collection","text":"tau_collection(taus, x::Float64)\n\nCalculation of the pdf for tau as a conflation of StratIntervals.\n\nThis uses the output of sample_interval with a Vector{StratInterval} and where postpredict is true.\n\nThe value of x is the evaluated using the conflation of the collection of stratigraphic intervals, that is, the tau for the co-occurrence of StratIntervals.\n\n\n\n\n\n","category":"method"},{"location":"turingmodel/#Sampling-stratigraphic-intervals,-posterior-predictive-distribution,-and-the-time-of-collections-of-stratigraphic-intervals","page":"Sampling a stratigraphic interval and posterior predictive","title":"Sampling stratigraphic intervals, posterior predictive distribution, and the time of collections of stratigraphic intervals","text":"","category":"section"},{"location":"turingmodel/","page":"Sampling a stratigraphic interval and posterior predictive","title":"Sampling a stratigraphic interval and posterior predictive","text":"This section describes how to sample from the model of stratigraphic interval once we have defined the data and priors. What comes next is to use MCMC sampling for approximating the posterior distribution of parameters.","category":"page"},{"location":"turingmodel/#Going-Bayesian-for-stratigraphic-intervals","page":"Sampling a stratigraphic interval and posterior predictive","title":"Going Bayesian for stratigraphic intervals","text":"","category":"section"},{"location":"turingmodel/","page":"Sampling a stratigraphic interval and posterior predictive","title":"Sampling a stratigraphic interval and posterior predictive","text":"We can define the posterior distribution of parameters describing a stratigraphic interval as follows:","category":"page"},{"location":"turingmodel/","page":"Sampling a stratigraphic interval and posterior predictive","title":"Sampling a stratigraphic interval and posterior predictive","text":"beginequation\n  beginaligned\n    f(theta_1theta_2lambda  boldsymboltau) = fracf(theta_1) f(theta_2) f(lambda) prod_i = 1^N f(tau_i  theta_1theta_2lambda)int f(theta_1) f(theta_2) f(lambda) prod_i = 1^N f(tau_i  theta_1theta_2lambda) mathrmdtheta_1 mathrmdtheta_2 mathrmdlambda\n  endaligned\nendequation","category":"page"},{"location":"turingmodel/","page":"Sampling a stratigraphic interval and posterior predictive","title":"Sampling a stratigraphic interval and posterior predictive","text":"where f(theta_1), f(theta_2), and f(lambda) are the priors of parameters, and prod_i = 1^N f(tau_i  theta_1theta_2lambda) is the likelihood function, where data are fixed. Here, the likelihood function is the ThreeParBeta distribution.","category":"page"},{"location":"turingmodel/","page":"Sampling a stratigraphic interval and posterior predictive","title":"Sampling a stratigraphic interval and posterior predictive","text":"Now we can use the function sample_stratinterval which takes an object of type StratInterval as input as well as settings for the MCMC sampling.","category":"page"},{"location":"turingmodel/","page":"Sampling a stratigraphic interval and posterior predictive","title":"Sampling a stratigraphic interval and posterior predictive","text":"It can also define whether we want to sample from the prior, and whether we want to calculate the posterior predictive distribution.","category":"page"},{"location":"turingmodel/","page":"Sampling a stratigraphic interval and posterior predictive","title":"Sampling a stratigraphic interval and posterior predictive","text":"Consider the following example, our vector of occurrences in time is [2.0, 3.1, 3.2, 4.6, 6.77], and we want to use a Normal prior for theta_1, an Exponential for theta_2, and again a Normal prior for lambda:","category":"page"},{"location":"turingmodel/","page":"Sampling a stratigraphic interval and posterior predictive","title":"Sampling a stratigraphic interval and posterior predictive","text":"using Distributions\nusing Turing\nusing StratIntervals\nusing StatsPlots\nusing Random\n\nRandom.seed!(119)\n\nsetprogress!(false)\n\ndata = [2.0, 3.1, 3.2, 4.6, 6.77]\nθ1_prior = Normal(10, 2)\nθ2_prior = Exponential(1)\nλ_prior = Normal(0, 1)\nmy_strinterval = StratInterval(data, θ1_prior, θ2_prior, λ_prior)\npost_samples = sample_stratinterval(my_strinterval, 10000, NUTS(), false, false) # sample from posterior\n\nplot(post_samples)\nsavefig(\"post_samples.svg\");\n\nnothing","category":"page"},{"location":"turingmodel/","page":"Sampling a stratigraphic interval and posterior predictive","title":"Sampling a stratigraphic interval and posterior predictive","text":"(Image: )","category":"page"},{"location":"turingmodel/","page":"Sampling a stratigraphic interval and posterior predictive","title":"Sampling a stratigraphic interval and posterior predictive","text":"We note a few things about the analysis: First, it took quite little time to run (but this depends on processor architechture, so it's not generalisable). Second, by inspecting the effective sample sizes (ESSs), both bulk and tail, we see they are quite high, (say above 600), and therefore we can suspect we are reaching convergence.","category":"page"},{"location":"turingmodel/","page":"Sampling a stratigraphic interval and posterior predictive","title":"Sampling a stratigraphic interval and posterior predictive","text":"The MCMC sampling, which is done via Turing.jl, returns the samples, provides a nice summary of the sampling, and also allows to actually plot the chains and marginal distributions. From the summary we can also read the posterior mean and quantiles.","category":"page"},{"location":"turingmodel/","page":"Sampling a stratigraphic interval and posterior predictive","title":"Sampling a stratigraphic interval and posterior predictive","text":"Turing.jl is a very powerful probabilistic language for Julia and allows to do many things with posterior samples, so make sure to take a look at their documentation for further details.","category":"page"},{"location":"turingmodel/#Sampling-from-the-prior","page":"Sampling a stratigraphic interval and posterior predictive","title":"Sampling from the prior","text":"","category":"section"},{"location":"turingmodel/","page":"Sampling a stratigraphic interval and posterior predictive","title":"Sampling a stratigraphic interval and posterior predictive","text":"We can sample from the priors, which means that during MCMC sampling the value of the likelihood function is always 1.0. This way we can build an unconditional distribution to make sure it represents what we set as prior. We can sample from the prior setting the argument prior = true in sample_stratinterval:","category":"page"},{"location":"turingmodel/","page":"Sampling a stratigraphic interval and posterior predictive","title":"Sampling a stratigraphic interval and posterior predictive","text":"using Distributions\nusing Turing\nusing StratIntervals\nusing StatsPlots\nusing Random\n\nRandom.seed!(14)\n\nsetprogress!(false)\n\ndata = [2.0, 3.1, 3.2, 4.6, 6.77]\nθ1_prior = Normal(10, 2)\nθ2_prior = Exponential(1)\nλ_prior = Normal(0, 1)\nmy_strinterval = StratInterval(data, θ1_prior, θ2_prior, λ_prior)\nprior_samples = sample_stratinterval(my_strinterval, 10000, NUTS(), true, false) # sample from prior\n\nplot(prior_samples)\nsavefig(\"prior_samples.svg\");\n\nnothing","category":"page"},{"location":"turingmodel/","page":"Sampling a stratigraphic interval and posterior predictive","title":"Sampling a stratigraphic interval and posterior predictive","text":"(Image: )","category":"page"},{"location":"turingmodel/#Calculating-the-posterior-predictive","page":"Sampling a stratigraphic interval and posterior predictive","title":"Calculating the posterior predictive","text":"","category":"section"},{"location":"turingmodel/","page":"Sampling a stratigraphic interval and posterior predictive","title":"Sampling a stratigraphic interval and posterior predictive","text":"Now that we have the samples from the posterior distribution of each parameter, we can integrate over them to build a distribution for the time tau, that is, the probability of observing occurrences through time integrating over uncertainty in parameter estimation. Such distribution is the posterior predictive.","category":"page"},{"location":"turingmodel/","page":"Sampling a stratigraphic interval and posterior predictive","title":"Sampling a stratigraphic interval and posterior predictive","text":"We can estimate the posterior distributions and the posterior predictive in one shot, by just setting the argument postpredict = true as follows:","category":"page"},{"location":"turingmodel/","page":"Sampling a stratigraphic interval and posterior predictive","title":"Sampling a stratigraphic interval and posterior predictive","text":"using Distributions\nusing Turing\nusing StratIntervals\nusing StatsPlots\nusing LaTeXStrings\nusing Random\n\nRandom.seed!(14)\n\nsetprogress!(false)\n\ndata = [2.0, 3.1, 3.2, 4.6, 6.77]\nθ1_prior = Normal(10, 2)\nθ2_prior = Exponential(1)\nλ_prior = Normal(0, 1)\nmy_strinterval = StratInterval(data, θ1_prior, θ2_prior, λ_prior)\npost_predictive = sample_stratinterval(my_strinterval, 10000, NUTS(), false, true) # sample from the posterior predictive\n\ndensity(post_predictive[2], label=L\"$\\tilde{\\tau}$\")\nsavefig(\"postpredict.svg\");\n\nnothing","category":"page"},{"location":"turingmodel/","page":"Sampling a stratigraphic interval and posterior predictive","title":"Sampling a stratigraphic interval and posterior predictive","text":"(Image: )","category":"page"},{"location":"turingmodel/#Helping-reach-convergence:-Suggestions-for-effective-MCMC","page":"Sampling a stratigraphic interval and posterior predictive","title":"Helping reach convergence: Suggestions for effective MCMC","text":"","category":"section"},{"location":"turingmodel/","page":"Sampling a stratigraphic interval and posterior predictive","title":"Sampling a stratigraphic interval and posterior predictive","text":"Convergence is a very challenging aspect of Bayesian inference. In theory we can only claim that our approximation of the posterior distributions converged to the target distribution in very specific cases and as sample size grows to infinity. This is of course of little (if any) practical value, as we never can sample to infinity.","category":"page"},{"location":"turingmodel/","page":"Sampling a stratigraphic interval and posterior predictive","title":"Sampling a stratigraphic interval and posterior predictive","text":"I like to use the no-U-turn sampler (NUTS), which is a very effective variant of the Hamiltonian Monte Carlo. Both these are very useful as all of our parameters are continuous. However, we can use any other sampler available from Turing.jl such as the Hamiltonian Monte Carlo (HMC), Gibbs (Gibbs), random-walk Metropolis-Hastings (MH), etc. We can try to use different samplers which may show different sampling efficiency in different situations and models. More efficient samplers mean better convergence.","category":"page"},{"location":"turingmodel/","page":"Sampling a stratigraphic interval and posterior predictive","title":"Sampling a stratigraphic interval and posterior predictive","text":"Another way of rising the ESS values is by letting the chains run by longer. Consider the following example, and compare it with our first run above:","category":"page"},{"location":"turingmodel/","page":"Sampling a stratigraphic interval and posterior predictive","title":"Sampling a stratigraphic interval and posterior predictive","text":"using Distributions\nusing Turing\nusing StratIntervals\nusing StatsPlots\nusing Random\n\nRandom.seed!(44)\n\nsetprogress!(false)\n\ndata = [2.0, 3.1, 3.2, 4.6, 6.77]\nθ1_prior = Normal(10, 2)\nθ2_prior = Exponential(1)\nλ_prior = Normal(0, 1)\nmy_strinterval = StratInterval(data, θ1_prior, θ2_prior, λ_prior)\npost_samples = sample_stratinterval(my_strinterval, 1000, NUTS(), false, false) # sample from posterior\n\nplot(post_samples)\nsavefig(\"lowess_samples.svg\");\n\nnothing","category":"page"},{"location":"turingmodel/","page":"Sampling a stratigraphic interval and posterior predictive","title":"Sampling a stratigraphic interval and posterior predictive","text":"(Image: )","category":"page"},{"location":"turingmodel/","page":"Sampling a stratigraphic interval and posterior predictive","title":"Sampling a stratigraphic interval and posterior predictive","text":"As we can see, the ESS values are quite low compared to our original ones, and the trace plots show less \"random\" behaviour of the sampled parameter values. These two are signs of poor convergence. Just letting the sampling to run by longer had the effect of improving convergence. ","category":"page"},{"location":"turingmodel/#Calculating-\\tau-for-a-collection-of-stratigraphic-intervals","page":"Sampling a stratigraphic interval and posterior predictive","title":"Calculating tau for a collection of stratigraphic intervals","text":"","category":"section"},{"location":"turingmodel/","page":"Sampling a stratigraphic interval and posterior predictive","title":"Sampling a stratigraphic interval and posterior predictive","text":"Now that we can calculate posterior distributions and posterior predictives, let us combine these tools for collections of stratigraphic intervals to build a distribution of the co-occurrence time.","category":"page"},{"location":"turingmodel/","page":"Sampling a stratigraphic interval and posterior predictive","title":"Sampling a stratigraphic interval and posterior predictive","text":"In this setting we have two stratigraphic intervals, each of which is a vector of time occurrences. We will set priors on each group of parameters, and sample from the posteriors. Then we will calculate the posterior predictive of each interval and finally combine them using conflation.","category":"page"},{"location":"turingmodel/","page":"Sampling a stratigraphic interval and posterior predictive","title":"Sampling a stratigraphic interval and posterior predictive","text":"using Distributions\nusing Turing\nusing StratIntervals\nusing StatsPlots\nusing Random\n\nRandom.seed!(67)\n\nsetprogress!(false)\n\nndata = 100;\niters = 10000;\n\n# first interval\ntrue_lambda_1 = 0;\ntrue_theta2_1 = 10;\ntrue_theta1_1 = 22;\ndata_1 = rand(ThreeParBeta(true_theta1_1, true_theta2_1, true_lambda_1), ndata);\n\n# second interval\ntrue_lambda_2 = 1;\ntrue_theta2_2 = 15;\ntrue_theta1_2 = 30;\ndata_2 = rand(ThreeParBeta(true_theta1_2, true_theta2_2, true_lambda_2), ndata);\n\n# specifying each StratInterval object\ninterval_1 = StratInterval(data_1, Normal(22, 3), Exponential(10), Normal(0,3));\ninterval_2 = StratInterval(data_2, Normal(30, 3), Exponential(15), Normal(1,3));\n\n# construct the vector of StratIntervals\nvecinterval = [interval_1, interval_2];\n\n# MCMC sampling and posterior predictive\nmystratint_postpredict_vec = sample_stratinterval(vecinterval, iters, NUTS(), false, true);\n\n# now calculate the conflation of posterior predictives for the collection interval_1, interval_2\n\nxx = 0:0.01:40;\nyy = map(x -> tau_collection(mystratint_postpredict_vec, x), xx);\n\nplot(xx, yy, label=\"Conflation\")\ndensity!(mystratint_postpredict_vec[1][2], label=\"Postpredictive 1\")\ndensity!(mystratint_postpredict_vec[2][2], label=\"Postpredictive 2\")\n\nsavefig(\"tau_collection.svg\");\n\nnothing","category":"page"},{"location":"turingmodel/","page":"Sampling a stratigraphic interval and posterior predictive","title":"Sampling a stratigraphic interval and posterior predictive","text":"(Image: )","category":"page"},{"location":"stratinterval/#Stratigraphic-intervals-and-how-to-define-them","page":"Stratigraphic intervals","title":"Stratigraphic intervals and how to define them","text":"","category":"section"},{"location":"stratinterval/#The-StratInterval-data-structure","page":"Stratigraphic intervals","title":"The StratInterval data structure","text":"","category":"section"},{"location":"stratinterval/","page":"Stratigraphic intervals","title":"Stratigraphic intervals","text":"The data structure that is provided in the package is called StratInterval. It provides four fields for specifying both data and priors:","category":"page"},{"location":"stratinterval/","page":"Stratigraphic intervals","title":"Stratigraphic intervals","text":"data is a vector of Float64 with the age occurrences\nθ1_prior prior distribution for theta_1  \nθ2_prior prior distribution for theta_2\nλ_prior prior distribution for lambda","category":"page"},{"location":"stratinterval/","page":"Stratigraphic intervals","title":"Stratigraphic intervals","text":"We will discuss below each of these elements.","category":"page"},{"location":"stratinterval/#Defining-a-stratigraphic-interval","page":"Stratigraphic intervals","title":"Defining a stratigraphic interval","text":"","category":"section"},{"location":"stratinterval/","page":"Stratigraphic intervals","title":"Stratigraphic intervals","text":"A stratigraphic interval is a collection of time occurrences preserved in the fossil record. For instance, Let us consider the Ammonite in the Figure below, it speciated at time theta_1, lived for some time, and then became extinct at time theta_2. The pattern of preservation is governed by a quantity called lambda, which determines how likely it is to become preserved as we proceed in time.","category":"page"},{"location":"stratinterval/","page":"Stratigraphic intervals","title":"Stratigraphic intervals","text":"Normally, we have access to some collection of preserved occurrences in time, but the first and last of these, called the First Appearance Datum (FAD) and Last Appearance Datum (LAD) have very little probability of being the true origination and extinction times of the species in the fossil record. If we use these quantities for measuring how long the species was living on earth, we will bias our estimates, and therefore consider FADs and LADs biaset estimators for the true origination and extinction times theta_1 and theta_2.","category":"page"},{"location":"stratinterval/","page":"Stratigraphic intervals","title":"Stratigraphic intervals","text":"The plots below show different patterns of preservation in which the histograms represet the relative frequence of fossil occurrences in time. As we can see, the patterns can be quite different depending on the value of lambda. In fact, the histograms are showing collections of occurrences sampled at random from these stratigraphic intervals for fixed values of theta_1, theta_2, and lambda.    ","category":"page"},{"location":"stratinterval/","page":"Stratigraphic intervals","title":"Stratigraphic intervals","text":"(Image: )","category":"page"},{"location":"stratinterval/","page":"Stratigraphic intervals","title":"Stratigraphic intervals","text":"Living Ammonite https://doi.org/10.7875/togopic.2020.08, fossil Ammonite https://commons.wikimedia.org/wiki/User:Ilzolende.","category":"page"},{"location":"stratinterval/#With-\"exact\"-data","page":"Stratigraphic intervals","title":"With \"exact\" data","text":"","category":"section"},{"location":"stratinterval/","page":"Stratigraphic intervals","title":"Stratigraphic intervals","text":"Any method makes assumptions about the data and how these were generated. This time we will make three assumptions:","category":"page"},{"location":"stratinterval/","page":"Stratigraphic intervals","title":"Stratigraphic intervals","text":"Preservation potential is continuous and constant through time,\nTime occurrences are measured without error\nPreservation of each occurrence is independent from the preservation of other occurrences. That is, occurrences are independent and identically distributed. ","category":"page"},{"location":"stratinterval/","page":"Stratigraphic intervals","title":"Stratigraphic intervals","text":"In this context, \"exact\" data, or occurrences measured without error means that there is no uncertainty associated to the age for a given occurrence. For example, a particular fossil may have its age dated as 32.4 Ma. Neither 31, nor 33, exactly 32.4. This is of course impossible as we cannot attain infinite precision in continuous measurements, but it is at least important that we can fix the data in a given model so that we can calculate parameter values later on. As an example, we may have a vector of fossil occurrences (in Ma) for a given extinct species as follows: [36.0, 35.8, 33.4, 33.01, 32.9].","category":"page"},{"location":"stratinterval/","page":"Stratigraphic intervals","title":"Stratigraphic intervals","text":"But again, this is not how the fossil record works. Anyone familiar with fossils and how we tell their age knows that for the vast majority of fossil occurrences have an interval for its age, that is, we can only guess its age with intrinsic error. For example, a given fossil may be said to be from about 34.0 and 32.3 Ma, or from the Miocene, which is essentially the interval between 23.03 and 5.333 Ma. How to deal with that undesirable property of real data?","category":"page"},{"location":"stratinterval/#Data-with-uncertainty:-Intervals","page":"Stratigraphic intervals","title":"Data with uncertainty: Intervals","text":"","category":"section"},{"location":"stratinterval/","page":"Stratigraphic intervals","title":"Stratigraphic intervals","text":"Let us consider an actual example from the fossil record. We downloaded some data for the Catfish genus Phractocephalus from the Paleobiology Database. Among other data in published references, we can focus on the age information of these occurrences. These are the columns early_interval, late_interval, max_ma, and min_ma.","category":"page"},{"location":"stratinterval/","page":"Stratigraphic intervals","title":"Stratigraphic intervals","text":"occurrence_no accepted_name early_interval late_interval max_ma min_ma midpoint_ma interval_length\n1088124 Phractocephalus acreornatus Late Miocene  11.63 5.333 8.4815 6.297\n1088132 Phractocephalus acreornatus Tortonian  11.63 7.246 9.438 4.384\n1088367 Phractocephalus nassi Late Miocene  11.63 5.333 8.4815 6.297\n1088377 Phractocephalus nassi Tortonian  11.63 7.246 9.438 4.384\n1312353 Phractocephalus Late Oligocene  27.82 23.03 25.425 4.79\n1312539 Phractocephalus Tortonian  11.63 7.246 9.438 4.384\n1368948 Phractocephalus hemiliopterus Laventan  13.7 10.9 12.3 2.8\n1386572 Phractocephalus Santacrucian Friasian 17.4 15.4 16.4 2\n1587033 Phractocephalus Langhian  15.98 13.82 14.9 2.16\n1595384 Phractocephalus Early Oligocene  33.9 27.82 30.86 6.08","category":"page"},{"location":"stratinterval/","page":"Stratigraphic intervals","title":"Stratigraphic intervals","text":"This shows how real-world age information is found in the literature: In the form of intervals. Quite often information comes from biostratigraphy or correlation, which uses age intervals according to the International Chronostratigraphic Chart. We need to use the numerical representation of such intervals, which we find in the columns max_ma and min_max. There are two options for using these data in analytical palaeobiology: We can calculate the midpoint of the interval and pretend that it is measured without error, or we can use the interval and sample from it. This way we can use e.g. resampling techniques for incorporating the uncertainty associated to each age. ","category":"page"},{"location":"stratinterval/#Specifying-priors","page":"Stratigraphic intervals","title":"Specifying priors","text":"","category":"section"},{"location":"stratinterval/","page":"Stratigraphic intervals","title":"Stratigraphic intervals","text":"Priors are distributions which describe our beliefs about possible values for the parameters of interest. For instance, if our model is a Binomial distribution with parameter theta, the proportion of success, a natural choice for describing our prior knowledge on it may be the Beta distribution, which is bound to the interval 01, such as proportions. The specific values of alpha and beta will define which values of theta are more probable. It is even possible that any value between 0 and 1 is equally likely, when alpha and beta are equal to 1.","category":"page"},{"location":"stratinterval/","page":"Stratigraphic intervals","title":"Stratigraphic intervals","text":"Distributions are defined using the Distributions.jl package. The syntax for defining priors is as follows:","category":"page"},{"location":"stratinterval/","page":"Stratigraphic intervals","title":"Stratigraphic intervals","text":"using Distributions\nusing StatsPlots\n\nparam1_prior = Normal(50, 3)\npdf(param1_prior, 51.0)\n\nplot(param1_prior)\nsavefig(\"prior.svg\");\n\nnothing","category":"page"},{"location":"stratinterval/","page":"Stratigraphic intervals","title":"Stratigraphic intervals","text":"(Image: )","category":"page"},{"location":"stratinterval/","page":"Stratigraphic intervals","title":"Stratigraphic intervals","text":"In the example above, we defined the prior on param1 as N(mu=50 sigma=3).","category":"page"},{"location":"stratinterval/","page":"Stratigraphic intervals","title":"Stratigraphic intervals","text":"We normally want priors that are at least mostly with support in tau in 0 infty). Also, we want to set the priors on theta_1 and theta_2 so that theta_1  theta_2 (because it is in Ma before present). Also, it is useful to set the prior on lambda centered at 0.0 but with enough variance as to allow values between -4 and 4, which allows a great amount of different shapes.","category":"page"},{"location":"stratinterval/#Collections-of-stratigraphic-intervals","page":"Stratigraphic intervals","title":"Collections of stratigraphic intervals","text":"","category":"section"},{"location":"stratinterval/","page":"Stratigraphic intervals","title":"Stratigraphic intervals","text":"Now we have different ways of specifying species through geologic time as a probability density function with respect to tau. We can use conflation to combine these if we have multiple so that we develop a probabilistic model for the co-occurrence of these individual intervals. In other words, such distribution describes the probability of all of them co-existing at the same time.","category":"page"},{"location":"stratinterval/","page":"Stratigraphic intervals","title":"Stratigraphic intervals","text":"The figure below shows the stratigraphic intervals of five different species of Ammonites. What is the distribution of having them living all at the same time, possibly co-existing in space? Such model can be used to tell the age of such co-existence, and can be used to estimate e.g. the age of fossil assemblages (blue distribution).","category":"page"},{"location":"stratinterval/","page":"Stratigraphic intervals","title":"Stratigraphic intervals","text":"(Image: )","category":"page"},{"location":"stratinterval/","page":"Stratigraphic intervals","title":"Stratigraphic intervals","text":"Ammonite drawings courtesy of Jorge W. Moreno-Bernal.","category":"page"},{"location":"conflation/#Conflation:-Combining-distributions","page":"Conflation of PDFs","title":"Conflation: Combining distributions","text":"","category":"section"},{"location":"conflation/","page":"Conflation of PDFs","title":"Conflation of PDFs","text":"Combining different distributions is not straitghforward (Genest and Zidek, 1986). However, the conflation of probability density functions is a useful procedure which combines them provided that each of them is independent (Hill, 2011; Hill and Miller, 2011).  Assuming that each distribution describing the same parameter is independent, we can define the composite distribution of tau for M intervals as the conflation of individual distributions:","category":"page"},{"location":"conflation/","page":"Conflation of PDFs","title":"Conflation of PDFs","text":"beginequation\n  beginaligned\n    Q(tau) = frac prod_i=1^M p_i(tau)int_-infty^infty prod_i=1^M p_i(x) mathrmdx\n  endaligned\nendequation","category":"page"},{"location":"conflation/","page":"Conflation of PDFs","title":"Conflation of PDFs","text":"Such distribution is useful e.g. when we want to build credible intervals for the time tau of co-occurrence of stratigraphic intervals. The conceptual interpretation as follows: M different lineages as represented by their stratigraphic intervals should coexist at most for some time interval when they all were alive. As the conflation of densities is a density itself, it can be used for asking questions on the probability of co-existence of lineages during some arbitrary time interval given the distribution.","category":"page"},{"location":"conflation/","page":"Conflation of PDFs","title":"Conflation of PDFs","text":"The application of conflation is however more general than the specific case where we combine different posterior predictives as the distribution of the co-occurrence of stratigraphic intervals. Ballen and Reinales (2025) have used the method for combining distributions into secondary calibrations as well as for estimating biogeographic events in divergence time estimation. As long as we have a vector of distributions, the calculation of their conflation is straightforward:","category":"page"},{"location":"conflation/","page":"Conflation of PDFs","title":"Conflation of PDFs","text":"using Distributions\nusing StatsPlots\nusing StratIntervals\n\ndists = product_distribution([Normal(10, 2), Normal(11, 4), Normal(8, 5)])\nxx = 5:0.0001:15\nyy = map(x -> conflate(dists, x), xx);\nplot(xx, yy, label=\"Conflation\")\nplot!(Normal(10, 2), label=\"Normal(10, 2)\")\nplot!(Normal(11, 4), label=\"Normal(11, 4)\")\nplot!(Normal(8, 5), label=\"Normal(8, 5)\")\nsavefig(\"conflation_example.svg\");\n\nnothing","category":"page"},{"location":"conflation/","page":"Conflation of PDFs","title":"Conflation of PDFs","text":"(Image: )","category":"page"},{"location":"conflation/","page":"Conflation of PDFs","title":"Conflation of PDFs","text":"The conflate function also supports an input consisting of a vector of distributions, that is, without the need to use product_distribution before calling conflate:","category":"page"},{"location":"conflation/","page":"Conflation of PDFs","title":"Conflation of PDFs","text":"using Distributions\nusing StratIntervals\n\nconflate([Normal(10, 2), Normal(11, 4), Normal(8, 5)], 9.8)\n\nconflate([Uniform(0,1), Uniform(0,1)], 0.5)\n\nnothing","category":"page"},{"location":"conflation/","page":"Conflation of PDFs","title":"Conflation of PDFs","text":"It is also possible to conflate empirical distributions defined by Kernel Densities. Supose we have two collections of values in the objects empirica1_vec and empirical2_vec which are of the same length, and we want to conflate them:","category":"page"},{"location":"conflation/","page":"Conflation of PDFs","title":"Conflation of PDFs","text":"using Random\nusing Distributions\nusing StatsPlots\nusing StratIntervals\nRandom.seed!(1507)\n\n#empirical1\nempirical1_vec = rand(Normal(0, 1), 20)\n#empirical2\nempirical2_vec = rand(Uniform(1, 2), 20)\n# stack them together in a matrix, column-wise\nempirical_matrix = [empirical1_vec empirical2_vec]\n\nxx = -4:0.01:4\nyy = map(x -> conflate(empirical_matrix, x), xx);\n\nplot(xx, yy, label=\"Conflation\")\ndensity!(empirical1_vec, label=\"Empirical 1\")\ndensity!(empirical2_vec, label=\"Empirical 2\")\nsavefig(\"conflation_empiricals_samelength.svg\");\n\nnothing","category":"page"},{"location":"conflation/","page":"Conflation of PDFs","title":"Conflation of PDFs","text":"(Image: )","category":"page"},{"location":"distributions/#Distribution-methods-documented-here","page":"Distributions","title":"Distribution methods documented here","text":"","category":"section"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"Some distributions are implemented either for the likelihood function or priors. ","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"Please note that all the recommended methods for new samplers and distributions have been implemented, so we can use pdf, cdf, minimum, maximum, insupport, as well as rand with the distributions herein described. For detais see the public API on the sidebar.","category":"page"},{"location":"distributions/#Three-Parameter-Beta-distribution","page":"Distributions","title":"Three-Parameter Beta distribution","text":"","category":"section"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"The Three-Parameter Beta distribution is defined as follows:","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"beginequation\n  beginaligned\n  f(tau theta_1theta_2lambda) = frac(theta_2 - tau)^-lambda(theta_2 - theta_1)^1-lambda B(11-lambda) mathrm if lambda leq 0 \n  mathrm where  B(11-lambda) = int_0^1 t^1+lambda-1 (1-t)^1-1 mathrmdt = frac11-lambda\n  endaligned\nendequation","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"and","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"beginequation\n  beginaligned\n  f(tau theta_1theta_2lambda) = frac(tau-theta_1)^lambda(theta_2 - theta_1)^1+lambda B(1+lambda1) mathrm if lambda  0 \n  mathrm where  B(1+lambda1) = int_0^1 t^1-1 (1-t)^1-lambda-1 mathrmdt = frac11+lambda\n  endaligned\nendequation","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"The parameters theta_1 and theta_2 are the endpoints of the tratigraphic interval, and lambda is the paremeter governing the probability of preservation through time.","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"Assuming that time occurrences are independent and identically distributed, we can also calculate the likelihood of observing a vector representing the collection of N time occurrences given a stratigraphic interval by the product of likelihoods of individual time occurrences:","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"beginequation\n  beginaligned\n    f(boldsymboltau theta_1theta_2lambda) = prod_i = 1^N f(tau_i  theta_1theta_2lambda)  \n  endaligned\nendequation","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"This is the core element of the model for inference of stratigraphic interval as it is used as likelihood function, which describes the probability of observing the data.","category":"page"},{"location":"distributions/#Reflected-Offset-Exponential-distribution","page":"Distributions","title":"Reflected-Offset Exponential distribution","text":"","category":"section"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"Sometimes we want priors which are asymmetric and one-tailed. One interesting option is the Exponential distribution, but unfortunately it is bounded to 0infty), and always has a tail to the right. Sometimes we may want an Exponential which is displaced to some arbitrary point in the Real line, and we may also want it to have the tail to the left  instead.","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"In order to satisfy these needs, the package provides the RefOffExponential distribution. It has an additional set of parameters, called offset o and reflection rho parameters. The offset is where the distribution will have its new zero, and the reflection quantity is either -1 or 1, the former for a reflection with respect to x = 0 and the latter the unreflected form.","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"The parameter theta is the usual scale parameter. Note that this last parameter is counted forward from the offset. For instance, if the offset is 50 and we want a distribution starting in 50 but with mean 100, theta will need to be 50. Note that if offset and reflection are being used, then the mean will be counting backwards from the offset.","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"The PDF of the ReffOffExponential is the following:","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"beginequation\n  beginaligned\n    f(x theta) = rho left(frac1theta e^-fracx-othetaright) quad x  0\n  endaligned\nendequation","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"This is an example of the RefOffExponential without offset and reflection, and mean = 4:","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"using Distributions\nusing StratIntervals\nusing StatsPlots\nplot(RefOffExponential(4, 0.0, 1))\nsavefig(\"refoffexp4_0_1.svg\");\n\nnothing","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"(Image: )","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"Now with offset = 10, and mean in 14, without reflection:","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"using Distributions\nusing StratIntervals\nusing StatsPlots\nplot(RefOffExponential(4, 10.0, 1))\nsavefig(\"refoffexp4_10_1.svg\");\n\nnothing","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"(Image: )","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"Now without offset, and mean in -6, with reflection:","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"using Distributions\nusing StratIntervals\nusing StatsPlots\nplot(RefOffExponential(6, 0.0, -1))\nsavefig(\"refoffexp6_0_minus1.svg\");\n\nnothing","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"(Image: )","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"And finally, with both offset = 20, mean = 15  and reflection:","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"using Distributions\nusing StratIntervals\nusing StatsPlots\nplot(RefOffExponential(5, 20, -1))\nsavefig(\"refoffexp5_20_minus1.svg\");\n\nnothing","category":"page"},{"location":"distributions/","page":"Distributions","title":"Distributions","text":"(Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = StratIntervals","category":"page"},{"location":"#StratIntervals.jl","page":"Home","title":"StratIntervals.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for the StratIntervals package. Please refer to Ballen (2025) for details as well as to the documentations herein.","category":"page"},{"location":"#Is-this-package-for-me?","page":"Home","title":"Is this package for me?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package is useful for you if:","category":"page"},{"location":"","page":"Home","title":"Home","text":"You have a series of occurrences in time, and want to estimate the time at which these events started and finished happening. Examples include a series of fossil occurrences for a given species for which we want to estimate the origination and extinction times.\nYou have a collection of multiple intervals as described above, and want to calculate the probability distribution for the time of co-occurrence of them, that is, the time at which these were co-existing. For example, we have stratigraphic intervals for different species that were found at the same fossil assemblage, and we want to estimate the time of the assemblage.\nWant to use the distributions implemented in this package for other purposes, for instance the Three-Parameter Beta distribution, or the Reflected-Offset Exponential distribution. ","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You may install the stable version of the package from the Julia Package General Registry with:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"StratIntervals\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Also, you may install the development version from GitHub:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"https://github.com/gaballench/StratIntervals.jl\")","category":"page"},{"location":"#Literature-cited","page":"Home","title":"Literature cited","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following references have been cited throughout the documentation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Ballen, G.A. (2025). A flexible Bayesian method for estimating stratigraphic intervals and their co-occurrence in time. BioRxiv https://doi.org/10.1101/2025.02.13.638199.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Ballen, G.A. & Reinales, S. (2025). tbea: tools for pre- and post-processing in Bayesian evolutionary analyses. Submitted to Evolutionary Journal of the Linnean Society. Preprint at BioRxiv https://doi.org/10.1101/2024.06.18.599561.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Genest, C. and Zidek, J. V. (1986). Combining probability distributions: A critique and an annotated bibliography. Statistical Science, 1(1):114–135.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Hill, T. P. (2011). Conflations of probability distributions. Transactions of the American Mathematical Society, 363(6):3351–3372.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Hill, T. P. and Miller, J. (2011). How to combine independent data sets for the same quantity. Chaos: An Interdisciplinary Journal of Nonlinear Science, 21(3):033102.","category":"page"}]
}
