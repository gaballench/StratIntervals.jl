<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Sampling a stratigraphic interval and posterior predictive · StratIntervals.jl</title><meta name="title" content="Sampling a stratigraphic interval and posterior predictive · StratIntervals.jl"/><meta property="og:title" content="Sampling a stratigraphic interval and posterior predictive · StratIntervals.jl"/><meta property="twitter:title" content="Sampling a stratigraphic interval and posterior predictive · StratIntervals.jl"/><meta name="description" content="Documentation for StratIntervals.jl."/><meta property="og:description" content="Documentation for StratIntervals.jl."/><meta property="twitter:description" content="Documentation for StratIntervals.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="StratIntervals.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="StratIntervals.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">StratIntervals.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../stratinterval/">Stratigraphic intervals</a></li><li><a class="tocitem" href="../distributions/">Distributions</a></li><li><a class="tocitem" href="../conflation/">Conflation of PDFs</a></li><li class="is-active"><a class="tocitem" href>Sampling a stratigraphic interval and posterior predictive</a><ul class="internal"><li><a class="tocitem" href="#Going-Bayesian-for-stratigraphic-intervals"><span>Going Bayesian for stratigraphic intervals</span></a></li><li><a class="tocitem" href="#Sampling-from-the-prior"><span>Sampling from the prior</span></a></li><li><a class="tocitem" href="#Calculating-the-posterior-predictive"><span>Calculating the posterior predictive</span></a></li><li><a class="tocitem" href="#Helping-reach-convergence:-Suggestions-for-effective-MCMC"><span>Helping reach convergence: Suggestions for effective MCMC</span></a></li><li><a class="tocitem" href="#Calculating-\\tau-for-a-collection-of-stratigraphic-intervals"><span>Calculating <span>$\tau$</span> for a collection of stratigraphic intervals</span></a></li></ul></li><li><a class="tocitem" href="../api/">Public  API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Sampling a stratigraphic interval and posterior predictive</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Sampling a stratigraphic interval and posterior predictive</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/gaballench/StratIntervals.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/gaballench/StratIntervals.jl/blob/main/docs/src/turingmodel.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Sampling-stratigraphic-intervals,-posterior-predictive-distribution,-and-the-time-of-collections-of-stratigraphic-intervals"><a class="docs-heading-anchor" href="#Sampling-stratigraphic-intervals,-posterior-predictive-distribution,-and-the-time-of-collections-of-stratigraphic-intervals">Sampling stratigraphic intervals, posterior predictive distribution, and the time of collections of stratigraphic intervals</a><a id="Sampling-stratigraphic-intervals,-posterior-predictive-distribution,-and-the-time-of-collections-of-stratigraphic-intervals-1"></a><a class="docs-heading-anchor-permalink" href="#Sampling-stratigraphic-intervals,-posterior-predictive-distribution,-and-the-time-of-collections-of-stratigraphic-intervals" title="Permalink"></a></h1><p>This section describes how to sample from the model of stratigraphic interval once we have defined the data and priors. What comes next is to use MCMC sampling for approximating the posterior distribution of parameters.</p><h2 id="Going-Bayesian-for-stratigraphic-intervals"><a class="docs-heading-anchor" href="#Going-Bayesian-for-stratigraphic-intervals">Going Bayesian for stratigraphic intervals</a><a id="Going-Bayesian-for-stratigraphic-intervals-1"></a><a class="docs-heading-anchor-permalink" href="#Going-Bayesian-for-stratigraphic-intervals" title="Permalink"></a></h2><p>We can define the posterior distribution of parameters describing a stratigraphic interval as follows:</p><p class="math-container">\[\begin{equation}
  \begin{aligned}
    f(\theta_1,\theta_2,\lambda | \boldsymbol{\tau}) = \frac{f(\theta_1) f(\theta_2) f(\lambda) \prod_{i = 1}^{N} f(\tau_i | \theta_1,\theta_2,\lambda)}{\int f(\theta_1) f(\theta_2) f(\lambda) \prod_{i = 1}^{N} f(\tau_i | \theta_1,\theta_2,\lambda) \mathrm{d}\theta_1 \mathrm{d}\theta_2 \mathrm{d}\lambda}
  \end{aligned}
\end{equation}\]</p><p>where <span>$f(\theta_1)$</span>, <span>$f(\theta_2)$</span>, and <span>$f(\lambda)$</span> are the priors of parameters, and <span>$\prod_{i = 1}^{N} f(\tau_i | \theta_1,\theta_2,\lambda)$</span> is the likelihood function, where data are fixed. Here, the likelihood function is the <code>ThreeParBeta</code> distribution.</p><p>Now we can use the function <code>sample_stratinterval</code> which takes an object of type <code>StratInterval</code> as input as well as settings for the MCMC sampling.</p><p>It can also define whether we want to sample from the prior, and whether we want to calculate the posterior predictive distribution.</p><p>Consider the following example, our vector of occurrences in time is <code>[2.0, 3.1, 3.2, 4.6, 6.77]</code>, and we want to use a Normal prior for <span>$\theta_1$</span>, an Exponential for <span>$\theta_2$</span>, and again a Normal prior for <span>$\lambda$</span>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Distributions</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Turing</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using StratIntervals</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using StatsPlots</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Random</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Random.seed!(119)</code><code class="nohighlight hljs ansi" style="display:block;">Random.TaskLocalRNG()</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; setprogress!(false)</code><code class="nohighlight hljs ansi" style="display:block;">[ Info: [Turing]: progress logging is disabled globally
[ Info: [AdvancedVI]: global PROGRESS is set as false
false</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; data = [2.0, 3.1, 3.2, 4.6, 6.77]</code><code class="nohighlight hljs ansi" style="display:block;">5-element Vector{Float64}:
 2.0
 3.1
 3.2
 4.6
 6.77</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; θ1_prior = Normal(10, 2)</code><code class="nohighlight hljs ansi" style="display:block;">Normal{Float64}(μ=10.0, σ=2.0)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; θ2_prior = Exponential(1)</code><code class="nohighlight hljs ansi" style="display:block;">Exponential{Float64}(θ=1.0)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; λ_prior = Normal(0, 1)</code><code class="nohighlight hljs ansi" style="display:block;">Normal{Float64}(μ=0.0, σ=1.0)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; my_strinterval = StratInterval(data, θ1_prior, θ2_prior, λ_prior)</code><code class="nohighlight hljs ansi" style="display:block;">StratInterval(Union{Real, ContinuousUnivariateDistribution, UnivariateDistribution{Continuous}, ContinuousDistribution{Univariate}}[2.0, 3.1, 3.2, 4.6, 6.77], Normal{Float64}(μ=10.0, σ=2.0), Exponential{Float64}(θ=1.0), Normal{Float64}(μ=0.0, σ=1.0))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; post_samples = sample_stratinterval(my_strinterval, 10000, NUTS(), false, false) # sample from posterior</code><code class="nohighlight hljs ansi" style="display:block;">┌ Info: Found initial step size
└   ϵ = 0.8
Chains MCMC chain (10000×15×1 Array{Float64, 3}):

Iterations        = 1001:1:11000
Number of chains  = 1
Samples per chain = 10000
Wall duration     = 9.08 seconds
Compute duration  = 9.08 seconds
parameters        = θ1, θ2, λ
internals         = lp, n_steps, is_accept, acceptance_rate, log_density, hamiltonian_energy, hamiltonian_energy_error, max_hamiltonian_energy_error, tree_depth, numerical_error, step_size, nom_step_size

Summary Statistics
 <span class="sgr1"> parameters      mean       std      mcse   ess_bulk    ess_tail      rhat    ⋯
 <span class="sgr90">     Symbol   Float64   Float64   Float64    Float64     Float64   Float64    ⋯

          θ1    9.4509    1.6527    0.0560   902.4670   1632.1169    1.0005    ⋯
          θ2    0.9698    0.5860    0.0196   854.0681   1137.5306    1.0013    ⋯
           λ   -0.6121    0.7758    0.0251   988.0057    963.0477    1.0019    ⋯
</span><span class="sgr36">                                                                1 column omitted

Quantiles
  parameters      2.5%     25.0%     50.0%     75.0%     97.5%
 </span><span class="sgr90">     Symbol   Float64   Float64   Float64   Float64   Float64

          θ1    6.9321    8.1375    9.2616   10.5556   12.9925
          θ2    0.0442    0.4598    0.9354    1.4857    1.9507
           λ   -2.1324   -1.1296   -0.6118   -0.1001    0.9030</span></span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; plot(post_samples)</code><code class="nohighlight hljs ansi" style="display:block;">Plot{Plots.GRBackend() n=6}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; savefig(&quot;post_samples.svg&quot;);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; nothing</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p><img src="../post_samples.svg" alt/></p><p>We note a few things about the analysis: First, it took quite little time to run (but this depends on processor architechture, so it&#39;s not generalisable). Second, by inspecting the effective sample sizes (ESSs), both bulk and tail, we see they are quite high, (say above 600), and therefore we can suspect we are reaching convergence.</p><p>The MCMC sampling, which is done via <a href="https://turinglang.org/">Turing.jl</a>, returns the samples, provides a nice summary of the sampling, and also allows to actually plot the chains and marginal distributions. From the summary we can also read the posterior mean and quantiles.</p><p><a href="https://turinglang.org/">Turing.jl</a> is a very powerful probabilistic language for Julia and allows to do many things with posterior samples, so make sure to take a look at their documentation for further details.</p><h2 id="Sampling-from-the-prior"><a class="docs-heading-anchor" href="#Sampling-from-the-prior">Sampling from the prior</a><a id="Sampling-from-the-prior-1"></a><a class="docs-heading-anchor-permalink" href="#Sampling-from-the-prior" title="Permalink"></a></h2><p>We can sample from the priors, which means that during MCMC sampling the value of the likelihood function is always 1.0. This way we can build an unconditional distribution to make sure it represents what we set as prior. We can sample from the prior setting the argument <code>prior = true</code> in <code>sample_stratinterval</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Distributions</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Turing</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using StratIntervals</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using StatsPlots</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Random</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Random.seed!(14)</code><code class="nohighlight hljs ansi" style="display:block;">Random.TaskLocalRNG()</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; setprogress!(false)</code><code class="nohighlight hljs ansi" style="display:block;">[ Info: [Turing]: progress logging is disabled globally
[ Info: [AdvancedVI]: global PROGRESS is set as false
false</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; data = [2.0, 3.1, 3.2, 4.6, 6.77]</code><code class="nohighlight hljs ansi" style="display:block;">5-element Vector{Float64}:
 2.0
 3.1
 3.2
 4.6
 6.77</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; θ1_prior = Normal(10, 2)</code><code class="nohighlight hljs ansi" style="display:block;">Normal{Float64}(μ=10.0, σ=2.0)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; θ2_prior = Exponential(1)</code><code class="nohighlight hljs ansi" style="display:block;">Exponential{Float64}(θ=1.0)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; λ_prior = Normal(0, 1)</code><code class="nohighlight hljs ansi" style="display:block;">Normal{Float64}(μ=0.0, σ=1.0)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; my_strinterval = StratInterval(data, θ1_prior, θ2_prior, λ_prior)</code><code class="nohighlight hljs ansi" style="display:block;">StratInterval(Union{Real, ContinuousUnivariateDistribution, UnivariateDistribution{Continuous}, ContinuousDistribution{Univariate}}[2.0, 3.1, 3.2, 4.6, 6.77], Normal{Float64}(μ=10.0, σ=2.0), Exponential{Float64}(θ=1.0), Normal{Float64}(μ=0.0, σ=1.0))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; prior_samples = sample_stratinterval(my_strinterval, 10000, NUTS(), true, false) # sample from prior</code><code class="nohighlight hljs ansi" style="display:block;">Chains MCMC chain (10000×4×1 Array{Float64, 3}):

Iterations        = 1:1:10000
Number of chains  = 1
Samples per chain = 10000
Wall duration     = 0.2 seconds
Compute duration  = 0.2 seconds
parameters        = θ1, θ2, λ
internals         = lp

Summary Statistics
 <span class="sgr1"> parameters      mean       std      mcse    ess_bulk    ess_tail      rhat   ⋯
 <span class="sgr90">     Symbol   Float64   Float64   Float64     Float64     Float64   Float64   ⋯

          θ1    9.9969    1.9935    0.0202   9710.8226   9602.2249    0.9999   ⋯
          θ2    0.9952    0.9979    0.0102   9852.3831   9582.1407    0.9999   ⋯
           λ    0.0135    0.9951    0.0100   9922.4059   9798.0272    1.0000   ⋯
</span><span class="sgr36">                                                                1 column omitted

Quantiles
  parameters      2.5%     25.0%     50.0%     75.0%     97.5%
 </span><span class="sgr90">     Symbol   Float64   Float64   Float64   Float64   Float64

          θ1    6.1334    8.6398    9.9656   11.3571   13.9619
          θ2    0.0261    0.2799    0.6841    1.3904    3.7261
           λ   -1.9499   -0.6677    0.0325    0.6844    1.9456</span></span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; plot(prior_samples)</code><code class="nohighlight hljs ansi" style="display:block;">Plot{Plots.GRBackend() n=6}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; savefig(&quot;prior_samples.svg&quot;);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; nothing</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p><img src="../post_samples.svg" alt/></p><h2 id="Calculating-the-posterior-predictive"><a class="docs-heading-anchor" href="#Calculating-the-posterior-predictive">Calculating the posterior predictive</a><a id="Calculating-the-posterior-predictive-1"></a><a class="docs-heading-anchor-permalink" href="#Calculating-the-posterior-predictive" title="Permalink"></a></h2><p>Now that we have the samples from the posterior distribution of each parameter, we can integrate over them to build a distribution for the time <span>$\tau$</span>, that is, the probability of observing occurrences through time integrating over uncertainty in parameter estimation. Such distribution is the posterior predictive.</p><p>We can estimate the posterior distributions and the posterior predictive in one shot, by just setting the argument <code>postpredict = true</code> as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Distributions</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Turing</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using StratIntervals</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using StatsPlots</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using LaTeXStrings</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: ArgumentError: Package LaTeXStrings not found in current path.
- Run `import Pkg; Pkg.add(&quot;LaTeXStrings&quot;)` to install the LaTeXStrings package.</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Random</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Random.seed!(14)</code><code class="nohighlight hljs ansi" style="display:block;">Random.TaskLocalRNG()</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; setprogress!(false)</code><code class="nohighlight hljs ansi" style="display:block;">[ Info: [Turing]: progress logging is disabled globally
[ Info: [AdvancedVI]: global PROGRESS is set as false
false</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; data = [2.0, 3.1, 3.2, 4.6, 6.77]</code><code class="nohighlight hljs ansi" style="display:block;">5-element Vector{Float64}:
 2.0
 3.1
 3.2
 4.6
 6.77</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; θ1_prior = Normal(10, 2)</code><code class="nohighlight hljs ansi" style="display:block;">Normal{Float64}(μ=10.0, σ=2.0)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; θ2_prior = Exponential(1)</code><code class="nohighlight hljs ansi" style="display:block;">Exponential{Float64}(θ=1.0)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; λ_prior = Normal(0, 1)</code><code class="nohighlight hljs ansi" style="display:block;">Normal{Float64}(μ=0.0, σ=1.0)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; my_strinterval = StratInterval(data, θ1_prior, θ2_prior, λ_prior)</code><code class="nohighlight hljs ansi" style="display:block;">StratInterval(Union{Real, ContinuousUnivariateDistribution, UnivariateDistribution{Continuous}, ContinuousDistribution{Univariate}}[2.0, 3.1, 3.2, 4.6, 6.77], Normal{Float64}(μ=10.0, σ=2.0), Exponential{Float64}(θ=1.0), Normal{Float64}(μ=0.0, σ=1.0))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; post_predictive = sample_stratinterval(my_strinterval, 10000, NUTS(), false, true) # sample from the posterior predictive</code><code class="nohighlight hljs ansi" style="display:block;">┌ Info: Found initial step size
└   ϵ = 0.4
(MCMC chain (10000×15×1 Array{Float64, 3}), [5.581406773835338, 2.847423821341468, 5.666637103498823, 3.244284076986596, 2.5982951829965906, 6.811382291575892, 4.751002183324583, 3.2120362881762445, 2.0647904225749514, 2.202070383866207  …  4.18279746541311, 0.5547690735132677, 8.541297140699017, 7.308012163777463, 1.5569880827360434, 1.4602238109839605, 7.30994339956605, 3.112002533122426, 1.403187591112795, 4.51935749427788])</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; density(post_predictive[2], label=L&quot;$\tilde{\tau}$&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: LoadError: UndefVarError: `@L_str` not defined in `Main`
Suggestion: check for spelling errors or missing imports.
Hint: a global variable of this name may be made accessible by importing LaTeXStrings in the current active module Main
in expression starting at REPL[15]:1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; savefig(&quot;postpredict.svg&quot;);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; nothing</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p><img src="../postpredict.svg" alt/></p><h2 id="Helping-reach-convergence:-Suggestions-for-effective-MCMC"><a class="docs-heading-anchor" href="#Helping-reach-convergence:-Suggestions-for-effective-MCMC">Helping reach convergence: Suggestions for effective MCMC</a><a id="Helping-reach-convergence:-Suggestions-for-effective-MCMC-1"></a><a class="docs-heading-anchor-permalink" href="#Helping-reach-convergence:-Suggestions-for-effective-MCMC" title="Permalink"></a></h2><p>Convergence is a very challenging aspect of Bayesian inference. In theory we can only claim that our approximation of the posterior distributions converged to the target distribution in very specific cases and as sample size grows to infinity. This is of course of little (if any) practical value, as we never can sample to infinity.</p><p>I like to use the no-U-turn sampler (<code>NUTS</code>), which is a very effective variant of the Hamiltonian Monte Carlo. Both these are very useful as all of our parameters are continuous. However, we can use any other sampler available from <code>Turing.jl</code> such as the Hamiltonian Monte Carlo (<code>HMC</code>), Gibbs (<code>Gibbs</code>), random-walk Metropolis-Hastings (<code>MH</code>), etc. We can try to use different samplers which may show different sampling efficiency in different situations and models. More efficient samplers mean better convergence.</p><p>Another way of rising the ESS values is by letting the chains run by longer. Consider the following example, and compare it with our first run above:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Distributions</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Turing</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using StratIntervals</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using StatsPlots</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Random</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Random.seed!(44)</code><code class="nohighlight hljs ansi" style="display:block;">Random.TaskLocalRNG()</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; setprogress!(false)</code><code class="nohighlight hljs ansi" style="display:block;">[ Info: [Turing]: progress logging is disabled globally
[ Info: [AdvancedVI]: global PROGRESS is set as false
false</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; data = [2.0, 3.1, 3.2, 4.6, 6.77]</code><code class="nohighlight hljs ansi" style="display:block;">5-element Vector{Float64}:
 2.0
 3.1
 3.2
 4.6
 6.77</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; θ1_prior = Normal(10, 2)</code><code class="nohighlight hljs ansi" style="display:block;">Normal{Float64}(μ=10.0, σ=2.0)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; θ2_prior = Exponential(1)</code><code class="nohighlight hljs ansi" style="display:block;">Exponential{Float64}(θ=1.0)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; λ_prior = Normal(0, 1)</code><code class="nohighlight hljs ansi" style="display:block;">Normal{Float64}(μ=0.0, σ=1.0)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; my_strinterval = StratInterval(data, θ1_prior, θ2_prior, λ_prior)</code><code class="nohighlight hljs ansi" style="display:block;">StratInterval(Union{Real, ContinuousUnivariateDistribution, UnivariateDistribution{Continuous}, ContinuousDistribution{Univariate}}[2.0, 3.1, 3.2, 4.6, 6.77], Normal{Float64}(μ=10.0, σ=2.0), Exponential{Float64}(θ=1.0), Normal{Float64}(μ=0.0, σ=1.0))</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; post_samples = sample_stratinterval(my_strinterval, 1000, NUTS(), false, false) # sample from posterior</code><code class="nohighlight hljs ansi" style="display:block;">┌ Info: Found initial step size
└   ϵ = 3.2
Chains MCMC chain (1000×15×1 Array{Float64, 3}):

Iterations        = 501:1:1500
Number of chains  = 1
Samples per chain = 1000
Wall duration     = 0.19 seconds
Compute duration  = 0.19 seconds
parameters        = θ1, θ2, λ
internals         = lp, n_steps, is_accept, acceptance_rate, log_density, hamiltonian_energy, hamiltonian_energy_error, max_hamiltonian_energy_error, tree_depth, numerical_error, step_size, nom_step_size

Summary Statistics
 <span class="sgr1"> parameters      mean       std      mcse   ess_bulk   ess_tail      rhat   e ⋯
 <span class="sgr90">     Symbol   Float64   Float64   Float64    Float64    Float64   Float64     ⋯

          θ1    9.8537    1.6407    0.1874    79.2509   119.4541    1.0145     ⋯
          θ2    1.0196    0.5843    0.0613    92.4226   227.9255    1.0110     ⋯
           λ   -0.6489    0.6039    0.0713    73.3889    75.7698    1.0019     ⋯
</span><span class="sgr36">                                                                1 column omitted

Quantiles
  parameters      2.5%     25.0%     50.0%     75.0%     97.5%
 </span><span class="sgr90">     Symbol   Float64   Float64   Float64   Float64   Float64

          θ1    6.9924    8.6712    9.8317   10.9611   13.4152
          θ2    0.0918    0.5402    0.9700    1.5988    1.9319
           λ   -1.9181   -1.0742   -0.5980   -0.2557    0.4942</span></span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; plot(post_samples)</code><code class="nohighlight hljs ansi" style="display:block;">Plot{Plots.GRBackend() n=6}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; savefig(&quot;lowess_samples.svg&quot;);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; nothing</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p><img src="../lowess_samples.svg" alt/></p><p>As we can see, the ESS values are quite low compared to our original ones, and the trace plots show less &quot;random&quot; behaviour of the sampled parameter values. These two are signs of poor convergence. Just letting the sampling to run by longer had the effect of improving convergence. </p><h2 id="Calculating-\\tau-for-a-collection-of-stratigraphic-intervals"><a class="docs-heading-anchor" href="#Calculating-\\tau-for-a-collection-of-stratigraphic-intervals">Calculating <span>$\tau$</span> for a collection of stratigraphic intervals</a><a id="Calculating-\\tau-for-a-collection-of-stratigraphic-intervals-1"></a><a class="docs-heading-anchor-permalink" href="#Calculating-\\tau-for-a-collection-of-stratigraphic-intervals" title="Permalink"></a></h2><p>Now that we can calculate posterior distributions and posterior predictives, let us combine these tools for collections of stratigraphic intervals to build a distribution of the co-occurrence time.</p><p>In this setting we have two stratigraphic intervals, each of which is a vector of time occurrences. We will set priors on each group of parameters, and sample from the posteriors. Then we will calculate the posterior predictive of each interval and finally combine them using conflation.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Distributions</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Turing</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using StratIntervals</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using StatsPlots</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Random</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; Random.seed!(67)</code><code class="nohighlight hljs ansi" style="display:block;">Random.TaskLocalRNG()</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; setprogress!(false)</code><code class="nohighlight hljs ansi" style="display:block;">[ Info: [Turing]: progress logging is disabled globally
[ Info: [AdvancedVI]: global PROGRESS is set as false
false</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; ndata = 100;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; iters = 10000;
       
       # first interval</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; true_lambda_1 = 0;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; true_theta2_1 = 10;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; true_theta1_1 = 22;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; data_1 = rand(ThreeParBeta(true_theta1_1, true_theta2_1, true_lambda_1), ndata);
       
       # second interval</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; true_lambda_2 = 1;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; true_theta2_2 = 15;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; true_theta1_2 = 30;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; data_2 = rand(ThreeParBeta(true_theta1_2, true_theta2_2, true_lambda_2), ndata);
       
       # specifying each StratInterval object</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; interval_1 = StratInterval(data_1, Normal(22, 3), Exponential(10), Normal(0,3));</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; interval_2 = StratInterval(data_2, Normal(30, 3), Exponential(15), Normal(1,3));
       
       # construct the vector of StratIntervals</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; vecinterval = [interval_1, interval_2];
       
       # MCMC sampling and posterior predictive</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; mystratint_postpredict_vec = sample_stratinterval(vecinterval, iters, NUTS(), false, true);
       
       # now calculate the conflation of posterior predictives for the collection interval_1, interval_2</code><code class="nohighlight hljs ansi" style="display:block;">┌ Info: Found initial step size
└   ϵ = 0.8
┌ Info: Found initial step size
└   ϵ = 0.4</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; xx = 0:0.01:40;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; yy = map(x -&gt; tau_collection(mystratint_postpredict_vec, x), xx);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; plot(xx, yy, label=&quot;Conflation&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">Plot{Plots.GRBackend() n=1}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; density!(mystratint_postpredict_vec[1][2], label=&quot;Postpredictive 1&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">Plot{Plots.GRBackend() n=2}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; density!(mystratint_postpredict_vec[2][2], label=&quot;Postpredictive 2&quot;)</code><code class="nohighlight hljs ansi" style="display:block;">Plot{Plots.GRBackend() n=3}</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; savefig(&quot;tau_collection.svg&quot;);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; nothing</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p><img src="../tau_collection.svg" alt/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../conflation/">« Conflation of PDFs</a><a class="docs-footer-nextpage" href="../api/">Public  API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Tuesday 25 February 2025 00:33">Tuesday 25 February 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
